(function(e,n){if("object"==typeof exports&&"object"==typeof module)module.exports=n();else if("function"==typeof define&&define.amd)define([],n);else{var r=n();for(var t in r)("object"==typeof exports?exports:e)[t]=r[t]}})(window,function(){return function(e){var n={};function r(t){if(n[t])return n[t].exports;var s=n[t]={i:t,l:!1,exports:{}};return e[t].call(s.exports,s,s.exports,r),s.l=!0,s.exports}return r.m=e,r.c=n,r.d=function(e,n,t){r.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:t})},r.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},r.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(n,"a",n),n},r.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},r.p="",r(r.s="./src/Centrifuge.ts")}({"./node_modules/@protobufjs/aspromise/index.js":function(module,exports,__webpack_require__){"use strict";eval("\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/aspromise/index.js?")},"./node_modules/@protobufjs/base64/index.js":function(module,exports,__webpack_require__){"use strict";eval('\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === "=")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join("");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = "invalid encoding";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/base64/index.js?')},"./node_modules/@protobufjs/eventemitter/index.js":function(module,exports,__webpack_require__){"use strict";eval("\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/eventemitter/index.js?")},"./node_modules/@protobufjs/float/index.js":function(module,exports,__webpack_require__){"use strict";eval('\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== "undefined") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== "undefined") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/float/index.js?')},"./node_modules/@protobufjs/inquire/index.js":function(module,exports,__webpack_require__){"use strict";eval('\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/inquire/index.js?')},"./node_modules/@protobufjs/pool/index.js":function(module,exports,__webpack_require__){"use strict";eval("\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/pool/index.js?")},"./node_modules/@protobufjs/utf8/index.js":function(module,exports,__webpack_require__){"use strict";eval('\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return "";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join("");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/utf8/index.js?')},"./node_modules/js-observable/dist/observable.js":function(module,exports,__webpack_require__){eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse { var i, a; }\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Observable\", function() { return Observable; });\nvar Observable = (function () {\r\n    function Observable() {\r\n        this.__callbacks = {};\r\n    }\r\n    Observable.prototype.on = function (events, fn) {\r\n        var _this = this;\r\n        events.replace(/[^\\s]+/g, function (name) {\r\n            (_this.__callbacks[name] = _this.__callbacks[name] || []).push(fn);\r\n            return '';\r\n        });\r\n        return this;\r\n    };\r\n    Observable.prototype.one = function (name, fn) {\r\n        fn['one'] = true;\r\n        return this.on(name, fn);\r\n    };\r\n    Observable.prototype.off = function (events, fn) {\r\n        var _this = this;\r\n        if (events === '*') {\r\n            this.__callbacks = {};\r\n        }\r\n        else if (fn) {\r\n            var arr = this.__callbacks[events];\r\n            for (var i = 0, cb = void 0; (cb = arr && arr[i]); ++i) {\r\n                if (cb === fn) {\r\n                    arr.splice(i, 1);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            events.replace(/[^\\s]+/g, function (name) {\r\n                _this.__callbacks[name] = [];\r\n                return '';\r\n            });\r\n        }\r\n        return this;\r\n    };\r\n    Observable.prototype.trigger = function (name, args) {\r\n        var fns = this.__callbacks[name] || [];\r\n        for (var i = 0, fn = void 0; (fn = fns[i]); ++i) {\r\n            if (!fn['busy']) {\r\n                fn['busy'] = true;\r\n                fn.apply(this, args);\r\n                if (fn['one']) {\r\n                    fns.splice(i, 1);\r\n                    i--;\r\n                }\r\n                fn['busy'] = false;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    return Observable;\r\n}());\r\n\r\n\n\n/***/ })\n/******/ ]);\n});\n\n//# sourceURL=webpack:///./node_modules/js-observable/dist/observable.js?")},"./node_modules/protobufjs/minimal.js":function(module,exports,__webpack_require__){"use strict";eval('// minimal library entry point.\r\n\r\n\r\nmodule.exports = __webpack_require__(/*! ./src/index-minimal */ "./node_modules/protobufjs/src/index-minimal.js");\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/minimal.js?')},"./node_modules/protobufjs/src/index-minimal.js":function(module,exports,__webpack_require__){"use strict";eval('\r\nvar protobuf = exports;\r\n\r\n/**\r\n * Build type, one of `"full"`, `"light"` or `"minimal"`.\r\n * @name build\r\n * @type {string}\r\n * @const\r\n */\r\nprotobuf.build = "minimal";\r\n\r\n// Serialization\r\nprotobuf.Writer       = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");\r\nprotobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ "./node_modules/protobufjs/src/writer_buffer.js");\r\nprotobuf.Reader       = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");\r\nprotobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ "./node_modules/protobufjs/src/reader_buffer.js");\r\n\r\n// Utility\r\nprotobuf.util         = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");\r\nprotobuf.rpc          = __webpack_require__(/*! ./rpc */ "./node_modules/protobufjs/src/rpc.js");\r\nprotobuf.roots        = __webpack_require__(/*! ./roots */ "./node_modules/protobufjs/src/roots.js");\r\nprotobuf.configure    = configure;\r\n\r\n/* istanbul ignore next */\r\n/**\r\n * Reconfigures the library according to the environment.\r\n * @returns {undefined}\r\n */\r\nfunction configure() {\r\n    protobuf.Reader._configure(protobuf.BufferReader);\r\n    protobuf.util._configure();\r\n}\r\n\r\n// Configure serialization\r\nprotobuf.Writer._configure(protobuf.BufferWriter);\r\nconfigure();\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/index-minimal.js?')},"./node_modules/protobufjs/src/reader.js":function(module,exports,__webpack_require__){"use strict";eval('\r\nmodule.exports = Reader;\r\n\r\nvar util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");\r\n\r\nvar BufferReader; // cyclic\r\n\r\nvar LongBits  = util.LongBits,\r\n    utf8      = util.utf8;\r\n\r\n/* istanbul ignore next */\r\nfunction indexOutOfRange(reader, writeLength) {\r\n    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);\r\n}\r\n\r\n/**\r\n * Constructs a new reader instance using the specified buffer.\r\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\r\n * @constructor\r\n * @param {Uint8Array} buffer Buffer to read from\r\n */\r\nfunction Reader(buffer) {\r\n\r\n    /**\r\n     * Read buffer.\r\n     * @type {Uint8Array}\r\n     */\r\n    this.buf = buffer;\r\n\r\n    /**\r\n     * Read buffer position.\r\n     * @type {number}\r\n     */\r\n    this.pos = 0;\r\n\r\n    /**\r\n     * Read buffer length.\r\n     * @type {number}\r\n     */\r\n    this.len = buffer.length;\r\n}\r\n\r\nvar create_array = typeof Uint8Array !== "undefined"\r\n    ? function create_typed_array(buffer) {\r\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\r\n            return new Reader(buffer);\r\n        throw Error("illegal buffer");\r\n    }\r\n    /* istanbul ignore next */\r\n    : function create_array(buffer) {\r\n        if (Array.isArray(buffer))\r\n            return new Reader(buffer);\r\n        throw Error("illegal buffer");\r\n    };\r\n\r\n/**\r\n * Creates a new reader using the specified buffer.\r\n * @function\r\n * @param {Uint8Array|Buffer} buffer Buffer to read from\r\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\r\n * @throws {Error} If `buffer` is not a valid buffer\r\n */\r\nReader.create = util.Buffer\r\n    ? function create_buffer_setup(buffer) {\r\n        return (Reader.create = function create_buffer(buffer) {\r\n            return util.Buffer.isBuffer(buffer)\r\n                ? new BufferReader(buffer)\r\n                /* istanbul ignore next */\r\n                : create_array(buffer);\r\n        })(buffer);\r\n    }\r\n    /* istanbul ignore next */\r\n    : create_array;\r\n\r\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\r\n\r\n/**\r\n * Reads a varint as an unsigned 32 bit value.\r\n * @function\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.uint32 = (function read_uint32_setup() {\r\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\r\n    return function read_uint32() {\r\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n\r\n        /* istanbul ignore if */\r\n        if ((this.pos += 5) > this.len) {\r\n            this.pos = this.len;\r\n            throw indexOutOfRange(this, 10);\r\n        }\r\n        return value;\r\n    };\r\n})();\r\n\r\n/**\r\n * Reads a varint as a signed 32 bit value.\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.int32 = function read_int32() {\r\n    return this.uint32() | 0;\r\n};\r\n\r\n/**\r\n * Reads a zig-zag encoded varint as a signed 32 bit value.\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.sint32 = function read_sint32() {\r\n    var value = this.uint32();\r\n    return value >>> 1 ^ -(value & 1) | 0;\r\n};\r\n\r\n/* eslint-disable no-invalid-this */\r\n\r\nfunction readLongVarint() {\r\n    // tends to deopt with local vars for octet etc.\r\n    var bits = new LongBits(0, 0);\r\n    var i = 0;\r\n    if (this.len - this.pos > 4) { // fast route (lo)\r\n        for (; i < 4; ++i) {\r\n            // 1st..4th\r\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\r\n            if (this.buf[this.pos++] < 128)\r\n                return bits;\r\n        }\r\n        // 5th\r\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\r\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\r\n        if (this.buf[this.pos++] < 128)\r\n            return bits;\r\n        i = 0;\r\n    } else {\r\n        for (; i < 3; ++i) {\r\n            /* istanbul ignore if */\r\n            if (this.pos >= this.len)\r\n                throw indexOutOfRange(this);\r\n            // 1st..3th\r\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\r\n            if (this.buf[this.pos++] < 128)\r\n                return bits;\r\n        }\r\n        // 4th\r\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\r\n        return bits;\r\n    }\r\n    if (this.len - this.pos > 4) { // fast route (hi)\r\n        for (; i < 5; ++i) {\r\n            // 6th..10th\r\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\r\n            if (this.buf[this.pos++] < 128)\r\n                return bits;\r\n        }\r\n    } else {\r\n        for (; i < 5; ++i) {\r\n            /* istanbul ignore if */\r\n            if (this.pos >= this.len)\r\n                throw indexOutOfRange(this);\r\n            // 6th..10th\r\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\r\n            if (this.buf[this.pos++] < 128)\r\n                return bits;\r\n        }\r\n    }\r\n    /* istanbul ignore next */\r\n    throw Error("invalid varint encoding");\r\n}\r\n\r\n/* eslint-enable no-invalid-this */\r\n\r\n/**\r\n * Reads a varint as a signed 64 bit value.\r\n * @name Reader#int64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads a varint as an unsigned 64 bit value.\r\n * @name Reader#uint64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads a zig-zag encoded varint as a signed 64 bit value.\r\n * @name Reader#sint64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads a varint as a boolean.\r\n * @returns {boolean} Value read\r\n */\r\nReader.prototype.bool = function read_bool() {\r\n    return this.uint32() !== 0;\r\n};\r\n\r\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\r\n    return (buf[end - 4]\r\n          | buf[end - 3] << 8\r\n          | buf[end - 2] << 16\r\n          | buf[end - 1] << 24) >>> 0;\r\n}\r\n\r\n/**\r\n * Reads fixed 32 bits as an unsigned 32 bit integer.\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.fixed32 = function read_fixed32() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 4 > this.len)\r\n        throw indexOutOfRange(this, 4);\r\n\r\n    return readFixed32_end(this.buf, this.pos += 4);\r\n};\r\n\r\n/**\r\n * Reads fixed 32 bits as a signed 32 bit integer.\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.sfixed32 = function read_sfixed32() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 4 > this.len)\r\n        throw indexOutOfRange(this, 4);\r\n\r\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\r\n};\r\n\r\n/* eslint-disable no-invalid-this */\r\n\r\nfunction readFixed64(/* this: Reader */) {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 8 > this.len)\r\n        throw indexOutOfRange(this, 8);\r\n\r\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\r\n}\r\n\r\n/* eslint-enable no-invalid-this */\r\n\r\n/**\r\n * Reads fixed 64 bits.\r\n * @name Reader#fixed64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads zig-zag encoded fixed 64 bits.\r\n * @name Reader#sfixed64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads a float (32 bit) as a number.\r\n * @function\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.float = function read_float() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 4 > this.len)\r\n        throw indexOutOfRange(this, 4);\r\n\r\n    var value = util.float.readFloatLE(this.buf, this.pos);\r\n    this.pos += 4;\r\n    return value;\r\n};\r\n\r\n/**\r\n * Reads a double (64 bit float) as a number.\r\n * @function\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.double = function read_double() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 8 > this.len)\r\n        throw indexOutOfRange(this, 4);\r\n\r\n    var value = util.float.readDoubleLE(this.buf, this.pos);\r\n    this.pos += 8;\r\n    return value;\r\n};\r\n\r\n/**\r\n * Reads a sequence of bytes preceeded by its length as a varint.\r\n * @returns {Uint8Array} Value read\r\n */\r\nReader.prototype.bytes = function read_bytes() {\r\n    var length = this.uint32(),\r\n        start  = this.pos,\r\n        end    = this.pos + length;\r\n\r\n    /* istanbul ignore if */\r\n    if (end > this.len)\r\n        throw indexOutOfRange(this, length);\r\n\r\n    this.pos += length;\r\n    if (Array.isArray(this.buf)) // plain array\r\n        return this.buf.slice(start, end);\r\n    return start === end // fix for IE 10/Win8 and others\' subarray returning array of size 1\r\n        ? new this.buf.constructor(0)\r\n        : this._slice.call(this.buf, start, end);\r\n};\r\n\r\n/**\r\n * Reads a string preceeded by its byte length as a varint.\r\n * @returns {string} Value read\r\n */\r\nReader.prototype.string = function read_string() {\r\n    var bytes = this.bytes();\r\n    return utf8.read(bytes, 0, bytes.length);\r\n};\r\n\r\n/**\r\n * Skips the specified number of bytes if specified, otherwise skips a varint.\r\n * @param {number} [length] Length if known, otherwise a varint is assumed\r\n * @returns {Reader} `this`\r\n */\r\nReader.prototype.skip = function skip(length) {\r\n    if (typeof length === "number") {\r\n        /* istanbul ignore if */\r\n        if (this.pos + length > this.len)\r\n            throw indexOutOfRange(this, length);\r\n        this.pos += length;\r\n    } else {\r\n        do {\r\n            /* istanbul ignore if */\r\n            if (this.pos >= this.len)\r\n                throw indexOutOfRange(this);\r\n        } while (this.buf[this.pos++] & 128);\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Skips the next element of the specified wire type.\r\n * @param {number} wireType Wire type received\r\n * @returns {Reader} `this`\r\n */\r\nReader.prototype.skipType = function(wireType) {\r\n    switch (wireType) {\r\n        case 0:\r\n            this.skip();\r\n            break;\r\n        case 1:\r\n            this.skip(8);\r\n            break;\r\n        case 2:\r\n            this.skip(this.uint32());\r\n            break;\r\n        case 3:\r\n            do { // eslint-disable-line no-constant-condition\r\n                if ((wireType = this.uint32() & 7) === 4)\r\n                    break;\r\n                this.skipType(wireType);\r\n            } while (true);\r\n            break;\r\n        case 5:\r\n            this.skip(4);\r\n            break;\r\n\r\n        /* istanbul ignore next */\r\n        default:\r\n            throw Error("invalid wire type " + wireType + " at offset " + this.pos);\r\n    }\r\n    return this;\r\n};\r\n\r\nReader._configure = function(BufferReader_) {\r\n    BufferReader = BufferReader_;\r\n\r\n    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";\r\n    util.merge(Reader.prototype, {\r\n\r\n        int64: function read_int64() {\r\n            return readLongVarint.call(this)[fn](false);\r\n        },\r\n\r\n        uint64: function read_uint64() {\r\n            return readLongVarint.call(this)[fn](true);\r\n        },\r\n\r\n        sint64: function read_sint64() {\r\n            return readLongVarint.call(this).zzDecode()[fn](false);\r\n        },\r\n\r\n        fixed64: function read_fixed64() {\r\n            return readFixed64.call(this)[fn](true);\r\n        },\r\n\r\n        sfixed64: function read_sfixed64() {\r\n            return readFixed64.call(this)[fn](false);\r\n        }\r\n\r\n    });\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/reader.js?')},"./node_modules/protobufjs/src/reader_buffer.js":function(module,exports,__webpack_require__){"use strict";eval('\r\nmodule.exports = BufferReader;\r\n\r\n// extends Reader\r\nvar Reader = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");\r\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\r\n\r\nvar util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");\r\n\r\n/**\r\n * Constructs a new buffer reader instance.\r\n * @classdesc Wire format reader using node buffers.\r\n * @extends Reader\r\n * @constructor\r\n * @param {Buffer} buffer Buffer to read from\r\n */\r\nfunction BufferReader(buffer) {\r\n    Reader.call(this, buffer);\r\n\r\n    /**\r\n     * Read buffer.\r\n     * @name BufferReader#buf\r\n     * @type {Buffer}\r\n     */\r\n}\r\n\r\n/* istanbul ignore else */\r\nif (util.Buffer)\r\n    BufferReader.prototype._slice = util.Buffer.prototype.slice;\r\n\r\n/**\r\n * @override\r\n */\r\nBufferReader.prototype.string = function read_string_buffer() {\r\n    var len = this.uint32(); // modifies pos\r\n    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));\r\n};\r\n\r\n/**\r\n * Reads a sequence of bytes preceeded by its length as a varint.\r\n * @name BufferReader#bytes\r\n * @function\r\n * @returns {Buffer} Value read\r\n */\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/reader_buffer.js?')},"./node_modules/protobufjs/src/roots.js":function(module,exports,__webpack_require__){"use strict";eval('\r\nmodule.exports = {};\r\n\r\n/**\r\n * Named roots.\r\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\r\n * Can also be used manually to make roots available accross modules.\r\n * @name roots\r\n * @type {Object.<string,Root>}\r\n * @example\r\n * // pbjs -r myroot -o compiled.js ...\r\n *\r\n * // in another module:\r\n * require("./compiled.js");\r\n *\r\n * // in any subsequent module:\r\n * var root = protobuf.roots["myroot"];\r\n */\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/roots.js?')},"./node_modules/protobufjs/src/rpc.js":function(module,exports,__webpack_require__){"use strict";eval('\r\n\r\n/**\r\n * Streaming RPC helpers.\r\n * @namespace\r\n */\r\nvar rpc = exports;\r\n\r\n/**\r\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\r\n * @typedef RPCImpl\r\n * @type {function}\r\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\r\n * @param {Uint8Array} requestData Request data\r\n * @param {RPCImplCallback} callback Callback function\r\n * @returns {undefined}\r\n * @example\r\n * function rpcImpl(method, requestData, callback) {\r\n *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code\r\n *         throw Error("no such method");\r\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\r\n *         callback(err, responseData);\r\n *     });\r\n * }\r\n */\r\n\r\n/**\r\n * Node-style callback as used by {@link RPCImpl}.\r\n * @typedef RPCImplCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any, otherwise `null`\r\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn\'t been an error\r\n * @returns {undefined}\r\n */\r\n\r\nrpc.Service = __webpack_require__(/*! ./rpc/service */ "./node_modules/protobufjs/src/rpc/service.js");\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/rpc.js?')},"./node_modules/protobufjs/src/rpc/service.js":function(module,exports,__webpack_require__){"use strict";eval('\r\nmodule.exports = Service;\r\n\r\nvar util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");\r\n\r\n// Extends EventEmitter\r\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\r\n\r\n/**\r\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\r\n *\r\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\r\n * @typedef rpc.ServiceMethodCallback\r\n * @template TRes extends Message<TRes>\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {TRes} [response] Response message\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\r\n * @typedef rpc.ServiceMethod\r\n * @template TReq extends Message<TReq>\r\n * @template TRes extends Message<TRes>\r\n * @type {function}\r\n * @param {TReq|Properties<TReq>} request Request message or plain object\r\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\r\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\r\n */\r\n\r\n/**\r\n * Constructs a new RPC service instance.\r\n * @classdesc An RPC service as returned by {@link Service#create}.\r\n * @exports rpc.Service\r\n * @extends util.EventEmitter\r\n * @constructor\r\n * @param {RPCImpl} rpcImpl RPC implementation\r\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\r\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\r\n */\r\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\r\n\r\n    if (typeof rpcImpl !== "function")\r\n        throw TypeError("rpcImpl must be a function");\r\n\r\n    util.EventEmitter.call(this);\r\n\r\n    /**\r\n     * RPC implementation. Becomes `null` once the service is ended.\r\n     * @type {RPCImpl|null}\r\n     */\r\n    this.rpcImpl = rpcImpl;\r\n\r\n    /**\r\n     * Whether requests are length-delimited.\r\n     * @type {boolean}\r\n     */\r\n    this.requestDelimited = Boolean(requestDelimited);\r\n\r\n    /**\r\n     * Whether responses are length-delimited.\r\n     * @type {boolean}\r\n     */\r\n    this.responseDelimited = Boolean(responseDelimited);\r\n}\r\n\r\n/**\r\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\r\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\r\n * @param {Constructor<TReq>} requestCtor Request constructor\r\n * @param {Constructor<TRes>} responseCtor Response constructor\r\n * @param {TReq|Properties<TReq>} request Request message or plain object\r\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\r\n * @returns {undefined}\r\n * @template TReq extends Message<TReq>\r\n * @template TRes extends Message<TRes>\r\n */\r\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\r\n\r\n    if (!request)\r\n        throw TypeError("request must be specified");\r\n\r\n    var self = this;\r\n    if (!callback)\r\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\r\n\r\n    if (!self.rpcImpl) {\r\n        setTimeout(function() { callback(Error("already ended")); }, 0);\r\n        return undefined;\r\n    }\r\n\r\n    try {\r\n        return self.rpcImpl(\r\n            method,\r\n            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),\r\n            function rpcCallback(err, response) {\r\n\r\n                if (err) {\r\n                    self.emit("error", err, method);\r\n                    return callback(err);\r\n                }\r\n\r\n                if (response === null) {\r\n                    self.end(/* endedByRPC */ true);\r\n                    return undefined;\r\n                }\r\n\r\n                if (!(response instanceof responseCtor)) {\r\n                    try {\r\n                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);\r\n                    } catch (err) {\r\n                        self.emit("error", err, method);\r\n                        return callback(err);\r\n                    }\r\n                }\r\n\r\n                self.emit("data", response, method);\r\n                return callback(null, response);\r\n            }\r\n        );\r\n    } catch (err) {\r\n        self.emit("error", err, method);\r\n        setTimeout(function() { callback(err); }, 0);\r\n        return undefined;\r\n    }\r\n};\r\n\r\n/**\r\n * Ends this service and emits the `end` event.\r\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\r\n * @returns {rpc.Service} `this`\r\n */\r\nService.prototype.end = function end(endedByRPC) {\r\n    if (this.rpcImpl) {\r\n        if (!endedByRPC) // signal end to rpcImpl\r\n            this.rpcImpl(null, null, null);\r\n        this.rpcImpl = null;\r\n        this.emit("end").off();\r\n    }\r\n    return this;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/rpc/service.js?')},"./node_modules/protobufjs/src/util/longbits.js":function(module,exports,__webpack_require__){"use strict";eval('\r\nmodule.exports = LongBits;\r\n\r\nvar util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");\r\n\r\n/**\r\n * Constructs new long bits.\r\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\r\n * @memberof util\r\n * @constructor\r\n * @param {number} lo Low 32 bits, unsigned\r\n * @param {number} hi High 32 bits, unsigned\r\n */\r\nfunction LongBits(lo, hi) {\r\n\r\n    // note that the casts below are theoretically unnecessary as of today, but older statically\r\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\r\n\r\n    /**\r\n     * Low bits.\r\n     * @type {number}\r\n     */\r\n    this.lo = lo >>> 0;\r\n\r\n    /**\r\n     * High bits.\r\n     * @type {number}\r\n     */\r\n    this.hi = hi >>> 0;\r\n}\r\n\r\n/**\r\n * Zero bits.\r\n * @memberof util.LongBits\r\n * @type {util.LongBits}\r\n */\r\nvar zero = LongBits.zero = new LongBits(0, 0);\r\n\r\nzero.toNumber = function() { return 0; };\r\nzero.zzEncode = zero.zzDecode = function() { return this; };\r\nzero.length = function() { return 1; };\r\n\r\n/**\r\n * Zero hash.\r\n * @memberof util.LongBits\r\n * @type {string}\r\n */\r\nvar zeroHash = LongBits.zeroHash = "\\0\\0\\0\\0\\0\\0\\0\\0";\r\n\r\n/**\r\n * Constructs new long bits from the specified number.\r\n * @param {number} value Value\r\n * @returns {util.LongBits} Instance\r\n */\r\nLongBits.fromNumber = function fromNumber(value) {\r\n    if (value === 0)\r\n        return zero;\r\n    var sign = value < 0;\r\n    if (sign)\r\n        value = -value;\r\n    var lo = value >>> 0,\r\n        hi = (value - lo) / 4294967296 >>> 0;\r\n    if (sign) {\r\n        hi = ~hi >>> 0;\r\n        lo = ~lo >>> 0;\r\n        if (++lo > 4294967295) {\r\n            lo = 0;\r\n            if (++hi > 4294967295)\r\n                hi = 0;\r\n        }\r\n    }\r\n    return new LongBits(lo, hi);\r\n};\r\n\r\n/**\r\n * Constructs new long bits from a number, long or string.\r\n * @param {Long|number|string} value Value\r\n * @returns {util.LongBits} Instance\r\n */\r\nLongBits.from = function from(value) {\r\n    if (typeof value === "number")\r\n        return LongBits.fromNumber(value);\r\n    if (util.isString(value)) {\r\n        /* istanbul ignore else */\r\n        if (util.Long)\r\n            value = util.Long.fromString(value);\r\n        else\r\n            return LongBits.fromNumber(parseInt(value, 10));\r\n    }\r\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\r\n};\r\n\r\n/**\r\n * Converts this long bits to a possibly unsafe JavaScript number.\r\n * @param {boolean} [unsigned=false] Whether unsigned or not\r\n * @returns {number} Possibly unsafe number\r\n */\r\nLongBits.prototype.toNumber = function toNumber(unsigned) {\r\n    if (!unsigned && this.hi >>> 31) {\r\n        var lo = ~this.lo + 1 >>> 0,\r\n            hi = ~this.hi     >>> 0;\r\n        if (!lo)\r\n            hi = hi + 1 >>> 0;\r\n        return -(lo + hi * 4294967296);\r\n    }\r\n    return this.lo + this.hi * 4294967296;\r\n};\r\n\r\n/**\r\n * Converts this long bits to a long.\r\n * @param {boolean} [unsigned=false] Whether unsigned or not\r\n * @returns {Long} Long\r\n */\r\nLongBits.prototype.toLong = function toLong(unsigned) {\r\n    return util.Long\r\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\r\n        /* istanbul ignore next */\r\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\r\n};\r\n\r\nvar charCodeAt = String.prototype.charCodeAt;\r\n\r\n/**\r\n * Constructs new long bits from the specified 8 characters long hash.\r\n * @param {string} hash Hash\r\n * @returns {util.LongBits} Bits\r\n */\r\nLongBits.fromHash = function fromHash(hash) {\r\n    if (hash === zeroHash)\r\n        return zero;\r\n    return new LongBits(\r\n        ( charCodeAt.call(hash, 0)\r\n        | charCodeAt.call(hash, 1) << 8\r\n        | charCodeAt.call(hash, 2) << 16\r\n        | charCodeAt.call(hash, 3) << 24) >>> 0\r\n    ,\r\n        ( charCodeAt.call(hash, 4)\r\n        | charCodeAt.call(hash, 5) << 8\r\n        | charCodeAt.call(hash, 6) << 16\r\n        | charCodeAt.call(hash, 7) << 24) >>> 0\r\n    );\r\n};\r\n\r\n/**\r\n * Converts this long bits to a 8 characters long hash.\r\n * @returns {string} Hash\r\n */\r\nLongBits.prototype.toHash = function toHash() {\r\n    return String.fromCharCode(\r\n        this.lo        & 255,\r\n        this.lo >>> 8  & 255,\r\n        this.lo >>> 16 & 255,\r\n        this.lo >>> 24      ,\r\n        this.hi        & 255,\r\n        this.hi >>> 8  & 255,\r\n        this.hi >>> 16 & 255,\r\n        this.hi >>> 24\r\n    );\r\n};\r\n\r\n/**\r\n * Zig-zag encodes this long bits.\r\n * @returns {util.LongBits} `this`\r\n */\r\nLongBits.prototype.zzEncode = function zzEncode() {\r\n    var mask =   this.hi >> 31;\r\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\r\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Zig-zag decodes this long bits.\r\n * @returns {util.LongBits} `this`\r\n */\r\nLongBits.prototype.zzDecode = function zzDecode() {\r\n    var mask = -(this.lo & 1);\r\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\r\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Calculates the length of this longbits when encoded as a varint.\r\n * @returns {number} Length\r\n */\r\nLongBits.prototype.length = function length() {\r\n    var part0 =  this.lo,\r\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\r\n        part2 =  this.hi >>> 24;\r\n    return part2 === 0\r\n         ? part1 === 0\r\n           ? part0 < 16384\r\n             ? part0 < 128 ? 1 : 2\r\n             : part0 < 2097152 ? 3 : 4\r\n           : part1 < 16384\r\n             ? part1 < 128 ? 5 : 6\r\n             : part1 < 2097152 ? 7 : 8\r\n         : part2 < 128 ? 9 : 10;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/util/longbits.js?')},"./node_modules/protobufjs/src/util/minimal.js":function(module,exports,__webpack_require__){"use strict";eval('/* WEBPACK VAR INJECTION */(function(global) {\r\nvar util = exports;\r\n\r\n// used to return a Promise where callback is omitted\r\nutil.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ "./node_modules/@protobufjs/aspromise/index.js");\r\n\r\n// converts to / from base64 encoded strings\r\nutil.base64 = __webpack_require__(/*! @protobufjs/base64 */ "./node_modules/@protobufjs/base64/index.js");\r\n\r\n// base class of rpc.Service\r\nutil.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ "./node_modules/@protobufjs/eventemitter/index.js");\r\n\r\n// float handling accross browsers\r\nutil.float = __webpack_require__(/*! @protobufjs/float */ "./node_modules/@protobufjs/float/index.js");\r\n\r\n// requires modules optionally and hides the call from bundlers\r\nutil.inquire = __webpack_require__(/*! @protobufjs/inquire */ "./node_modules/@protobufjs/inquire/index.js");\r\n\r\n// converts to / from utf8 encoded strings\r\nutil.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ "./node_modules/@protobufjs/utf8/index.js");\r\n\r\n// provides a node-like buffer pool in the browser\r\nutil.pool = __webpack_require__(/*! @protobufjs/pool */ "./node_modules/@protobufjs/pool/index.js");\r\n\r\n// utility to work with the low and high bits of a 64 bit value\r\nutil.LongBits = __webpack_require__(/*! ./longbits */ "./node_modules/protobufjs/src/util/longbits.js");\r\n\r\n/**\r\n * An immuable empty array.\r\n * @memberof util\r\n * @type {Array.<*>}\r\n * @const\r\n */\r\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\r\n\r\n/**\r\n * An immutable empty object.\r\n * @type {Object}\r\n * @const\r\n */\r\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\r\n\r\n/**\r\n * Whether running within node or not.\r\n * @memberof util\r\n * @type {boolean}\r\n * @const\r\n */\r\nutil.isNode = Boolean(global.process && global.process.versions && global.process.versions.node);\r\n\r\n/**\r\n * Tests if the specified value is an integer.\r\n * @function\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is an integer\r\n */\r\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\r\n    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;\r\n};\r\n\r\n/**\r\n * Tests if the specified value is a string.\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is a string\r\n */\r\nutil.isString = function isString(value) {\r\n    return typeof value === "string" || value instanceof String;\r\n};\r\n\r\n/**\r\n * Tests if the specified value is a non-null object.\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is a non-null object\r\n */\r\nutil.isObject = function isObject(value) {\r\n    return value && typeof value === "object";\r\n};\r\n\r\n/**\r\n * Checks if a property on a message is considered to be present.\r\n * This is an alias of {@link util.isSet}.\r\n * @function\r\n * @param {Object} obj Plain object or message instance\r\n * @param {string} prop Property name\r\n * @returns {boolean} `true` if considered to be present, otherwise `false`\r\n */\r\nutil.isset =\r\n\r\n/**\r\n * Checks if a property on a message is considered to be present.\r\n * @param {Object} obj Plain object or message instance\r\n * @param {string} prop Property name\r\n * @returns {boolean} `true` if considered to be present, otherwise `false`\r\n */\r\nutil.isSet = function isSet(obj, prop) {\r\n    var value = obj[prop];\r\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\r\n        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\r\n    return false;\r\n};\r\n\r\n/**\r\n * Any compatible Buffer instance.\r\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node\'s typings.\r\n * @interface Buffer\r\n * @extends Uint8Array\r\n */\r\n\r\n/**\r\n * Node\'s Buffer class if available.\r\n * @type {Constructor<Buffer>}\r\n */\r\nutil.Buffer = (function() {\r\n    try {\r\n        var Buffer = util.inquire("buffer").Buffer;\r\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\r\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\r\n    } catch (e) {\r\n        /* istanbul ignore next */\r\n        return null;\r\n    }\r\n})();\r\n\r\n// Internal alias of or polyfull for Buffer.from.\r\nutil._Buffer_from = null;\r\n\r\n// Internal alias of or polyfill for Buffer.allocUnsafe.\r\nutil._Buffer_allocUnsafe = null;\r\n\r\n/**\r\n * Creates a new buffer of whatever type supported by the environment.\r\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\r\n * @returns {Uint8Array|Buffer} Buffer\r\n */\r\nutil.newBuffer = function newBuffer(sizeOrArray) {\r\n    /* istanbul ignore next */\r\n    return typeof sizeOrArray === "number"\r\n        ? util.Buffer\r\n            ? util._Buffer_allocUnsafe(sizeOrArray)\r\n            : new util.Array(sizeOrArray)\r\n        : util.Buffer\r\n            ? util._Buffer_from(sizeOrArray)\r\n            : typeof Uint8Array === "undefined"\r\n                ? sizeOrArray\r\n                : new Uint8Array(sizeOrArray);\r\n};\r\n\r\n/**\r\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\r\n * @type {Constructor<Uint8Array>}\r\n */\r\nutil.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;\r\n\r\n/**\r\n * Any compatible Long instance.\r\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\r\n * @interface Long\r\n * @property {number} low Low bits\r\n * @property {number} high High bits\r\n * @property {boolean} unsigned Whether unsigned or not\r\n */\r\n\r\n/**\r\n * Long.js\'s Long class if available.\r\n * @type {Constructor<Long>}\r\n */\r\nutil.Long = /* istanbul ignore next */ global.dcodeIO && /* istanbul ignore next */ global.dcodeIO.Long || util.inquire("long");\r\n\r\n/**\r\n * Regular expression used to verify 2 bit (`bool`) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\r\nutil.key2Re = /^true|false|0|1$/;\r\n\r\n/**\r\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\r\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\r\n\r\n/**\r\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\r\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\r\n\r\n/**\r\n * Converts a number or long to an 8 characters long hash string.\r\n * @param {Long|number} value Value to convert\r\n * @returns {string} Hash\r\n */\r\nutil.longToHash = function longToHash(value) {\r\n    return value\r\n        ? util.LongBits.from(value).toHash()\r\n        : util.LongBits.zeroHash;\r\n};\r\n\r\n/**\r\n * Converts an 8 characters long hash string to a long or number.\r\n * @param {string} hash Hash\r\n * @param {boolean} [unsigned=false] Whether unsigned or not\r\n * @returns {Long|number} Original value\r\n */\r\nutil.longFromHash = function longFromHash(hash, unsigned) {\r\n    var bits = util.LongBits.fromHash(hash);\r\n    if (util.Long)\r\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\r\n    return bits.toNumber(Boolean(unsigned));\r\n};\r\n\r\n/**\r\n * Merges the properties of the source object into the destination object.\r\n * @memberof util\r\n * @param {Object.<string,*>} dst Destination object\r\n * @param {Object.<string,*>} src Source object\r\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\r\n * @returns {Object.<string,*>} Destination object\r\n */\r\nfunction merge(dst, src, ifNotSet) { // used by converters\r\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\r\n        if (dst[keys[i]] === undefined || !ifNotSet)\r\n            dst[keys[i]] = src[keys[i]];\r\n    return dst;\r\n}\r\n\r\nutil.merge = merge;\r\n\r\n/**\r\n * Converts the first character of a string to lower case.\r\n * @param {string} str String to convert\r\n * @returns {string} Converted string\r\n */\r\nutil.lcFirst = function lcFirst(str) {\r\n    return str.charAt(0).toLowerCase() + str.substring(1);\r\n};\r\n\r\n/**\r\n * Creates a custom error constructor.\r\n * @memberof util\r\n * @param {string} name Error name\r\n * @returns {Constructor<Error>} Custom error constructor\r\n */\r\nfunction newError(name) {\r\n\r\n    function CustomError(message, properties) {\r\n\r\n        if (!(this instanceof CustomError))\r\n            return new CustomError(message, properties);\r\n\r\n        // Error.call(this, message);\r\n        // ^ just returns a new error instance because the ctor can be called as a function\r\n\r\n        Object.defineProperty(this, "message", { get: function() { return message; } });\r\n\r\n        /* istanbul ignore next */\r\n        if (Error.captureStackTrace) // node\r\n            Error.captureStackTrace(this, CustomError);\r\n        else\r\n            Object.defineProperty(this, "stack", { value: (new Error()).stack || "" });\r\n\r\n        if (properties)\r\n            merge(this, properties);\r\n    }\r\n\r\n    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\r\n\r\n    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });\r\n\r\n    CustomError.prototype.toString = function toString() {\r\n        return this.name + ": " + this.message;\r\n    };\r\n\r\n    return CustomError;\r\n}\r\n\r\nutil.newError = newError;\r\n\r\n/**\r\n * Constructs a new protocol error.\r\n * @classdesc Error subclass indicating a protocol specifc error.\r\n * @memberof util\r\n * @extends Error\r\n * @template T extends Message<T>\r\n * @constructor\r\n * @param {string} message Error message\r\n * @param {Object.<string,*>} [properties] Additional properties\r\n * @example\r\n * try {\r\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\r\n * } catch (e) {\r\n *     if (e instanceof ProtocolError && e.instance)\r\n *         console.log("decoded so far: " + JSON.stringify(e.instance));\r\n * }\r\n */\r\nutil.ProtocolError = newError("ProtocolError");\r\n\r\n/**\r\n * So far decoded message instance.\r\n * @name util.ProtocolError#instance\r\n * @type {Message<T>}\r\n */\r\n\r\n/**\r\n * A OneOf getter as returned by {@link util.oneOfGetter}.\r\n * @typedef OneOfGetter\r\n * @type {function}\r\n * @returns {string|undefined} Set field name, if any\r\n */\r\n\r\n/**\r\n * Builds a getter for a oneof\'s present field name.\r\n * @param {string[]} fieldNames Field names\r\n * @returns {OneOfGetter} Unbound getter\r\n */\r\nutil.oneOfGetter = function getOneOf(fieldNames) {\r\n    var fieldMap = {};\r\n    for (var i = 0; i < fieldNames.length; ++i)\r\n        fieldMap[fieldNames[i]] = 1;\r\n\r\n    /**\r\n     * @returns {string|undefined} Set field name, if any\r\n     * @this Object\r\n     * @ignore\r\n     */\r\n    return function() { // eslint-disable-line consistent-return\r\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\r\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\r\n                return keys[i];\r\n    };\r\n};\r\n\r\n/**\r\n * A OneOf setter as returned by {@link util.oneOfSetter}.\r\n * @typedef OneOfSetter\r\n * @type {function}\r\n * @param {string|undefined} value Field name\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Builds a setter for a oneof\'s present field name.\r\n * @param {string[]} fieldNames Field names\r\n * @returns {OneOfSetter} Unbound setter\r\n */\r\nutil.oneOfSetter = function setOneOf(fieldNames) {\r\n\r\n    /**\r\n     * @param {string} name Field name\r\n     * @returns {undefined}\r\n     * @this Object\r\n     * @ignore\r\n     */\r\n    return function(name) {\r\n        for (var i = 0; i < fieldNames.length; ++i)\r\n            if (fieldNames[i] !== name)\r\n                delete this[fieldNames[i]];\r\n    };\r\n};\r\n\r\n/**\r\n * Default conversion options used for {@link Message#toJSON} implementations.\r\n *\r\n * These options are close to proto3\'s JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\r\n *\r\n * - Longs become strings\r\n * - Enums become string keys\r\n * - Bytes become base64 encoded strings\r\n * - (Sub-)Messages become plain objects\r\n * - Maps become plain objects with all string keys\r\n * - Repeated fields become arrays\r\n * - NaN and Infinity for float and double fields become strings\r\n *\r\n * @type {IConversionOptions}\r\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\r\n */\r\nutil.toJSONOptions = {\r\n    longs: String,\r\n    enums: String,\r\n    bytes: String,\r\n    json: true\r\n};\r\n\r\nutil._configure = function() {\r\n    var Buffer = util.Buffer;\r\n    /* istanbul ignore if */\r\n    if (!Buffer) {\r\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\r\n        return;\r\n    }\r\n    // because node 4.x buffers are incompatible & immutable\r\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\r\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\r\n        /* istanbul ignore next */\r\n        function Buffer_from(value, encoding) {\r\n            return new Buffer(value, encoding);\r\n        };\r\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\r\n        /* istanbul ignore next */\r\n        function Buffer_allocUnsafe(size) {\r\n            return new Buffer(size);\r\n        };\r\n};\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/util/minimal.js?')},"./node_modules/protobufjs/src/writer.js":function(module,exports,__webpack_require__){"use strict";eval("\r\nmodule.exports = Writer;\r\n\r\nvar util      = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\r\n\r\nvar BufferWriter; // cyclic\r\n\r\nvar LongBits  = util.LongBits,\r\n    base64    = util.base64,\r\n    utf8      = util.utf8;\r\n\r\n/**\r\n * Constructs a new writer operation instance.\r\n * @classdesc Scheduled writer operation.\r\n * @constructor\r\n * @param {function(*, Uint8Array, number)} fn Function to call\r\n * @param {number} len Value byte length\r\n * @param {*} val Value to write\r\n * @ignore\r\n */\r\nfunction Op(fn, len, val) {\r\n\r\n    /**\r\n     * Function to call.\r\n     * @type {function(Uint8Array, number, *)}\r\n     */\r\n    this.fn = fn;\r\n\r\n    /**\r\n     * Value byte length.\r\n     * @type {number}\r\n     */\r\n    this.len = len;\r\n\r\n    /**\r\n     * Next operation.\r\n     * @type {Writer.Op|undefined}\r\n     */\r\n    this.next = undefined;\r\n\r\n    /**\r\n     * Value to write.\r\n     * @type {*}\r\n     */\r\n    this.val = val; // type varies\r\n}\r\n\r\n/* istanbul ignore next */\r\nfunction noop() {} // eslint-disable-line no-empty-function\r\n\r\n/**\r\n * Constructs a new writer state instance.\r\n * @classdesc Copied writer state.\r\n * @memberof Writer\r\n * @constructor\r\n * @param {Writer} writer Writer to copy state from\r\n * @ignore\r\n */\r\nfunction State(writer) {\r\n\r\n    /**\r\n     * Current head.\r\n     * @type {Writer.Op}\r\n     */\r\n    this.head = writer.head;\r\n\r\n    /**\r\n     * Current tail.\r\n     * @type {Writer.Op}\r\n     */\r\n    this.tail = writer.tail;\r\n\r\n    /**\r\n     * Current buffer length.\r\n     * @type {number}\r\n     */\r\n    this.len = writer.len;\r\n\r\n    /**\r\n     * Next state.\r\n     * @type {State|null}\r\n     */\r\n    this.next = writer.states;\r\n}\r\n\r\n/**\r\n * Constructs a new writer instance.\r\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\r\n * @constructor\r\n */\r\nfunction Writer() {\r\n\r\n    /**\r\n     * Current length.\r\n     * @type {number}\r\n     */\r\n    this.len = 0;\r\n\r\n    /**\r\n     * Operations head.\r\n     * @type {Object}\r\n     */\r\n    this.head = new Op(noop, 0, 0);\r\n\r\n    /**\r\n     * Operations tail\r\n     * @type {Object}\r\n     */\r\n    this.tail = this.head;\r\n\r\n    /**\r\n     * Linked forked states.\r\n     * @type {Object|null}\r\n     */\r\n    this.states = null;\r\n\r\n    // When a value is written, the writer calculates its byte length and puts it into a linked\r\n    // list of operations to perform when finish() is called. This both allows us to allocate\r\n    // buffers of the exact required size and reduces the amount of work we have to do compared\r\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\r\n    // part is just a linked list walk calling operations with already prepared values.\r\n}\r\n\r\n/**\r\n * Creates a new writer.\r\n * @function\r\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\r\n */\r\nWriter.create = util.Buffer\r\n    ? function create_buffer_setup() {\r\n        return (Writer.create = function create_buffer() {\r\n            return new BufferWriter();\r\n        })();\r\n    }\r\n    /* istanbul ignore next */\r\n    : function create_array() {\r\n        return new Writer();\r\n    };\r\n\r\n/**\r\n * Allocates a buffer of the specified size.\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\nWriter.alloc = function alloc(size) {\r\n    return new util.Array(size);\r\n};\r\n\r\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\r\n/* istanbul ignore else */\r\nif (util.Array !== Array)\r\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\r\n\r\n/**\r\n * Pushes a new operation to the queue.\r\n * @param {function(Uint8Array, number, *)} fn Function to call\r\n * @param {number} len Value byte length\r\n * @param {number} val Value to write\r\n * @returns {Writer} `this`\r\n * @private\r\n */\r\nWriter.prototype._push = function push(fn, len, val) {\r\n    this.tail = this.tail.next = new Op(fn, len, val);\r\n    this.len += len;\r\n    return this;\r\n};\r\n\r\nfunction writeByte(val, buf, pos) {\r\n    buf[pos] = val & 255;\r\n}\r\n\r\nfunction writeVarint32(val, buf, pos) {\r\n    while (val > 127) {\r\n        buf[pos++] = val & 127 | 128;\r\n        val >>>= 7;\r\n    }\r\n    buf[pos] = val;\r\n}\r\n\r\n/**\r\n * Constructs a new varint writer operation instance.\r\n * @classdesc Scheduled varint writer operation.\r\n * @extends Op\r\n * @constructor\r\n * @param {number} len Value byte length\r\n * @param {number} val Value to write\r\n * @ignore\r\n */\r\nfunction VarintOp(len, val) {\r\n    this.len = len;\r\n    this.next = undefined;\r\n    this.val = val;\r\n}\r\n\r\nVarintOp.prototype = Object.create(Op.prototype);\r\nVarintOp.prototype.fn = writeVarint32;\r\n\r\n/**\r\n * Writes an unsigned 32 bit value as a varint.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.uint32 = function write_uint32(value) {\r\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\r\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\r\n    this.len += (this.tail = this.tail.next = new VarintOp(\r\n        (value = value >>> 0)\r\n                < 128       ? 1\r\n        : value < 16384     ? 2\r\n        : value < 2097152   ? 3\r\n        : value < 268435456 ? 4\r\n        :                     5,\r\n    value)).len;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Writes a signed 32 bit value as a varint.\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.int32 = function write_int32(value) {\r\n    return value < 0\r\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\r\n        : this.uint32(value);\r\n};\r\n\r\n/**\r\n * Writes a 32 bit value as a varint, zig-zag encoded.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.sint32 = function write_sint32(value) {\r\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\r\n};\r\n\r\nfunction writeVarint64(val, buf, pos) {\r\n    while (val.hi) {\r\n        buf[pos++] = val.lo & 127 | 128;\r\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\r\n        val.hi >>>= 7;\r\n    }\r\n    while (val.lo > 127) {\r\n        buf[pos++] = val.lo & 127 | 128;\r\n        val.lo = val.lo >>> 7;\r\n    }\r\n    buf[pos++] = val.lo;\r\n}\r\n\r\n/**\r\n * Writes an unsigned 64 bit value as a varint.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.uint64 = function write_uint64(value) {\r\n    var bits = LongBits.from(value);\r\n    return this._push(writeVarint64, bits.length(), bits);\r\n};\r\n\r\n/**\r\n * Writes a signed 64 bit value as a varint.\r\n * @function\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.int64 = Writer.prototype.uint64;\r\n\r\n/**\r\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.sint64 = function write_sint64(value) {\r\n    var bits = LongBits.from(value).zzEncode();\r\n    return this._push(writeVarint64, bits.length(), bits);\r\n};\r\n\r\n/**\r\n * Writes a boolish value as a varint.\r\n * @param {boolean} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.bool = function write_bool(value) {\r\n    return this._push(writeByte, 1, value ? 1 : 0);\r\n};\r\n\r\nfunction writeFixed32(val, buf, pos) {\r\n    buf[pos    ] =  val         & 255;\r\n    buf[pos + 1] =  val >>> 8   & 255;\r\n    buf[pos + 2] =  val >>> 16  & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\n/**\r\n * Writes an unsigned 32 bit value as fixed 32 bits.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.fixed32 = function write_fixed32(value) {\r\n    return this._push(writeFixed32, 4, value >>> 0);\r\n};\r\n\r\n/**\r\n * Writes a signed 32 bit value as fixed 32 bits.\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\r\n\r\n/**\r\n * Writes an unsigned 64 bit value as fixed 64 bits.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.fixed64 = function write_fixed64(value) {\r\n    var bits = LongBits.from(value);\r\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\r\n};\r\n\r\n/**\r\n * Writes a signed 64 bit value as fixed 64 bits.\r\n * @function\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\r\n\r\n/**\r\n * Writes a float (32 bit).\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.float = function write_float(value) {\r\n    return this._push(util.float.writeFloatLE, 4, value);\r\n};\r\n\r\n/**\r\n * Writes a double (64 bit float).\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.double = function write_double(value) {\r\n    return this._push(util.float.writeDoubleLE, 8, value);\r\n};\r\n\r\nvar writeBytes = util.Array.prototype.set\r\n    ? function writeBytes_set(val, buf, pos) {\r\n        buf.set(val, pos); // also works for plain array values\r\n    }\r\n    /* istanbul ignore next */\r\n    : function writeBytes_for(val, buf, pos) {\r\n        for (var i = 0; i < val.length; ++i)\r\n            buf[pos + i] = val[i];\r\n    };\r\n\r\n/**\r\n * Writes a sequence of bytes.\r\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.bytes = function write_bytes(value) {\r\n    var len = value.length >>> 0;\r\n    if (!len)\r\n        return this._push(writeByte, 1, 0);\r\n    if (util.isString(value)) {\r\n        var buf = Writer.alloc(len = base64.length(value));\r\n        base64.decode(value, buf, 0);\r\n        value = buf;\r\n    }\r\n    return this.uint32(len)._push(writeBytes, len, value);\r\n};\r\n\r\n/**\r\n * Writes a string.\r\n * @param {string} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.string = function write_string(value) {\r\n    var len = utf8.length(value);\r\n    return len\r\n        ? this.uint32(len)._push(utf8.write, len, value)\r\n        : this._push(writeByte, 1, 0);\r\n};\r\n\r\n/**\r\n * Forks this writer's state by pushing it to a stack.\r\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.fork = function fork() {\r\n    this.states = new State(this);\r\n    this.head = this.tail = new Op(noop, 0, 0);\r\n    this.len = 0;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Resets this instance to the last state.\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.reset = function reset() {\r\n    if (this.states) {\r\n        this.head   = this.states.head;\r\n        this.tail   = this.states.tail;\r\n        this.len    = this.states.len;\r\n        this.states = this.states.next;\r\n    } else {\r\n        this.head = this.tail = new Op(noop, 0, 0);\r\n        this.len  = 0;\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.ldelim = function ldelim() {\r\n    var head = this.head,\r\n        tail = this.tail,\r\n        len  = this.len;\r\n    this.reset().uint32(len);\r\n    if (len) {\r\n        this.tail.next = head.next; // skip noop\r\n        this.tail = tail;\r\n        this.len += len;\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Finishes the write operation.\r\n * @returns {Uint8Array} Finished buffer\r\n */\r\nWriter.prototype.finish = function finish() {\r\n    var head = this.head.next, // skip noop\r\n        buf  = this.constructor.alloc(this.len),\r\n        pos  = 0;\r\n    while (head) {\r\n        head.fn(head.val, buf, pos);\r\n        pos += head.len;\r\n        head = head.next;\r\n    }\r\n    // this.head = this.tail = null;\r\n    return buf;\r\n};\r\n\r\nWriter._configure = function(BufferWriter_) {\r\n    BufferWriter = BufferWriter_;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/writer.js?")},"./node_modules/protobufjs/src/writer_buffer.js":function(module,exports,__webpack_require__){"use strict";eval('\r\nmodule.exports = BufferWriter;\r\n\r\n// extends Writer\r\nvar Writer = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");\r\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\r\n\r\nvar util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");\r\n\r\nvar Buffer = util.Buffer;\r\n\r\n/**\r\n * Constructs a new buffer writer instance.\r\n * @classdesc Wire format writer using node buffers.\r\n * @extends Writer\r\n * @constructor\r\n */\r\nfunction BufferWriter() {\r\n    Writer.call(this);\r\n}\r\n\r\n/**\r\n * Allocates a buffer of the specified size.\r\n * @param {number} size Buffer size\r\n * @returns {Buffer} Buffer\r\n */\r\nBufferWriter.alloc = function alloc_buffer(size) {\r\n    return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);\r\n};\r\n\r\nvar writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === "set"\r\n    ? function writeBytesBuffer_set(val, buf, pos) {\r\n        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\r\n                           // also works for plain array values\r\n    }\r\n    /* istanbul ignore next */\r\n    : function writeBytesBuffer_copy(val, buf, pos) {\r\n        if (val.copy) // Buffer values\r\n            val.copy(buf, pos, 0, val.length);\r\n        else for (var i = 0; i < val.length;) // plain array values\r\n            buf[pos++] = val[i++];\r\n    };\r\n\r\n/**\r\n * @override\r\n */\r\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\r\n    if (util.isString(value))\r\n        value = util._Buffer_from(value, "base64");\r\n    var len = value.length >>> 0;\r\n    this.uint32(len);\r\n    if (len)\r\n        this._push(writeBytesBuffer, len, value);\r\n    return this;\r\n};\r\n\r\nfunction writeStringBuffer(val, buf, pos) {\r\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\r\n        util.utf8.write(val, buf, pos);\r\n    else\r\n        buf.utf8Write(val, pos);\r\n}\r\n\r\n/**\r\n * @override\r\n */\r\nBufferWriter.prototype.string = function write_string_buffer(value) {\r\n    var len = Buffer.byteLength(value);\r\n    this.uint32(len);\r\n    if (len)\r\n        this._push(writeStringBuffer, len, value);\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * Finishes the write operation.\r\n * @name BufferWriter#finish\r\n * @function\r\n * @returns {Buffer} Finished buffer\r\n */\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/writer_buffer.js?')},"./node_modules/webpack/buildin/global.js":function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1, eval)("this");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === "object") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?')},"./src/Centrifuge.ts":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Centrifuge\", function() { return Centrifuge; });\n/* harmony import */ var _Functions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Functions */ \"./src/Functions.ts\");\n/* harmony import */ var js_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-observable */ \"./node_modules/js-observable/dist/observable.js\");\n/* harmony import */ var js_observable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(js_observable__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Subscription */ \"./src/Subscription.ts\");\n/* harmony import */ var _Proto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Proto */ \"./src/Proto.js\");\n/* harmony import */ var _Proto__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_Proto__WEBPACK_IMPORTED_MODULE_3__);\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\n\r\n\r\n\r\nvar Centrifuge = (function (_super) {\r\n    __extends(Centrifuge, _super);\r\n    function Centrifuge(config) {\r\n        var _this = _super.call(this) || this;\r\n        _this._config = {};\r\n        _this._status = 'disconnected';\r\n        _this._isSockJS = false;\r\n        _this._transport = null;\r\n        _this._transportName = null;\r\n        _this._transportClosed = true;\r\n        _this._reconnect = true;\r\n        _this._reconnecting = false;\r\n        _this._numRefreshFailed = 0;\r\n        _this._refreshTimeout = null;\r\n        _this._pongTimeout = null;\r\n        _this._pingInterval = null;\r\n        _this._commandId = 0;\r\n        _this._commands = [];\r\n        _this._isBatching = false;\r\n        _this._isAuthBatching = false;\r\n        _this._authChannels = {};\r\n        _this._clientID = null;\r\n        _this._callbacks = {};\r\n        _this._subs = {};\r\n        _this._retries = 0;\r\n        _this._latency = null;\r\n        _this._latencyStart = null;\r\n        _this._lastMessageID = {};\r\n        _this._configure(config);\r\n        return _this;\r\n    }\r\n    Object.defineProperty(Centrifuge.prototype, \"isConnected\", {\r\n        get: function () {\r\n            return this._status === 'connected';\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Centrifuge.prototype, \"isDisconnected\", {\r\n        get: function () {\r\n            return this._status === 'disconnected';\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Centrifuge.prototype.connect = function () {\r\n        if (this.isConnected) {\r\n            this._debug('Connect called when already connected');\r\n            return;\r\n        }\r\n        if (this._status === 'connecting') {\r\n            return;\r\n        }\r\n        this._debug('Start connecting');\r\n        this._setStatus('connecting');\r\n        this._clientID = null;\r\n        this._reconnect = true;\r\n        this._setTransport();\r\n    };\r\n    Centrifuge.prototype.disconnect = function () {\r\n        this._disconnect('client');\r\n    };\r\n    Centrifuge.prototype.ping = function () {\r\n        this.addCommand({\r\n            method: _Proto__WEBPACK_IMPORTED_MODULE_3__[\"proto\"].MethodType.PING\r\n        }).then(function (result) {\r\n        }, function (error) {\r\n        });\r\n    };\r\n    Centrifuge.prototype.startBatching = function () {\r\n        this._isBatching = true;\r\n    };\r\n    Centrifuge.prototype.stopBatching = function (flush) {\r\n        if (flush === void 0) { flush = false; }\r\n        this._isBatching = false;\r\n        if (flush === true) {\r\n            this.flush();\r\n        }\r\n    };\r\n    Centrifuge.prototype.flush = function () {\r\n        var commands = this._commands.slice();\r\n        this._send(commands);\r\n        this._commands = [];\r\n    };\r\n    Centrifuge.prototype.startAuthBatching = function () {\r\n        this._isAuthBatching = true;\r\n    };\r\n    Centrifuge.prototype.stopAuthBatching = function () {\r\n        var _this = this;\r\n        var i;\r\n        var channel;\r\n        this._isAuthBatching = false;\r\n        var channels = [];\r\n        for (channel in this._authChannels) {\r\n            if (this._authChannels.hasOwnProperty(channel)) {\r\n                if (!this._getSub(channel)) {\r\n                    continue;\r\n                }\r\n                channels.push(channel);\r\n            }\r\n        }\r\n        this._authChannels = {};\r\n        if (channels.length === 0) {\r\n            return;\r\n        }\r\n        var cb = function (err, _data) {\r\n            if (err === true) {\r\n                _this._debug('Authorization request failed');\r\n                for (i in channels) {\r\n                    if (channels.hasOwnProperty(i)) {\r\n                        channel = channels[i];\r\n                        _this._subscribeError({\r\n                            message: 'authorization request failed',\r\n                        }, channel);\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n            var batch = false;\r\n            if (!_this._isBatching) {\r\n                _this.startBatching();\r\n                batch = true;\r\n            }\r\n            for (i in channels) {\r\n                if (channels.hasOwnProperty(i)) {\r\n                    channel = channels[i];\r\n                    var channelResponse = _data[channel];\r\n                    if (!channelResponse) {\r\n                        _this._subscribeError({\r\n                            message: 'channel not found in authorization response',\r\n                        }, channel);\r\n                        continue;\r\n                    }\r\n                    if (!channelResponse.status || channelResponse.status === 200) {\r\n                        var msg = {\r\n                            method: _Proto__WEBPACK_IMPORTED_MODULE_3__[\"proto\"].MethodType.SUBSCRIBE,\r\n                            params: {\r\n                                channel: channel,\r\n                                client: _this._clientID,\r\n                                info: channelResponse.info,\r\n                                sign: channelResponse.sign\r\n                            },\r\n                        };\r\n                        if (_this._recover(channel) === true) {\r\n                            msg.params.recover = true;\r\n                            msg.params.last = _this._getLastID(channel);\r\n                        }\r\n                        _this.addCommand(msg).then(function (result) {\r\n                            _this._subscribeResult(result, channel);\r\n                        }, function (error) {\r\n                        });\r\n                    }\r\n                    else {\r\n                        _this._subscribeError({\r\n                            message: channelResponse.status,\r\n                        }, channel);\r\n                    }\r\n                }\r\n            }\r\n            if (batch) {\r\n                _this.stopBatching(true);\r\n            }\r\n        };\r\n        var data = {\r\n            client: this._clientID,\r\n            channels: channels,\r\n        };\r\n        if (Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(this._config.onPrivateChannelAuth)) {\r\n            this._config.onPrivateChannelAuth({\r\n                data: data,\r\n            }, cb);\r\n        }\r\n        else {\r\n            this._request(this._config.authEndpoint, this._config.authParams, this._config.authHeaders, data, cb);\r\n        }\r\n    };\r\n    Centrifuge.prototype.subscribe = function (channel, events) {\r\n        if (!Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(channel)) {\r\n            throw new Error('Illegal argument type: channel must be a string');\r\n        }\r\n        if (!this._config.resubscribe && !this.isConnected) {\r\n            throw new Error('Can not only subscribe in connected state when resubscribe option is off');\r\n        }\r\n        var currentSub = this._getSub(channel);\r\n        if (currentSub !== null) {\r\n            currentSub.setEvents(events);\r\n            if (currentSub.isUnsubscribed) {\r\n                currentSub.subscribe();\r\n            }\r\n            return currentSub;\r\n        }\r\n        else {\r\n            var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_2__[\"Subscription\"](this, channel, events);\r\n            this._subs[channel] = sub;\r\n            sub.subscribe();\r\n            return sub;\r\n        }\r\n    };\r\n    Centrifuge.prototype.subscribeSub = function (sub) {\r\n        var _this = this;\r\n        var channel = sub.channel;\r\n        if (!(channel in this._subs)) {\r\n            this._subs[channel] = sub;\r\n        }\r\n        if (!this.isConnected) {\r\n            sub.setNew();\r\n            return;\r\n        }\r\n        sub.setSubscribing();\r\n        if (Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"startsWith\"])(channel, this._config.privateChannelPrefix)) {\r\n            if (this._isAuthBatching) {\r\n                this._authChannels[channel] = true;\r\n            }\r\n            else {\r\n                this.startAuthBatching();\r\n                this.subscribeSub(sub);\r\n                this.stopAuthBatching();\r\n            }\r\n        }\r\n        else {\r\n            var msg = {\r\n                method: _Proto__WEBPACK_IMPORTED_MODULE_3__[\"proto\"].MethodType.SUBSCRIBE,\r\n                params: {\r\n                    channel: channel,\r\n                }\r\n            };\r\n            if (this._recover(channel) === true) {\r\n                msg.params.recover = true;\r\n                msg.params.last = this._getLastID(channel);\r\n            }\r\n            this.addCommand(msg).then(function (result) {\r\n                _this._subscribeResult(result, channel);\r\n            }, function (error) {\r\n                _this._subscribeError(error, channel);\r\n            });\r\n        }\r\n    };\r\n    Centrifuge.prototype.unsubscribeSub = function (sub) {\r\n        if (this.isConnected) {\r\n            this.addCommand({\r\n                method: _Proto__WEBPACK_IMPORTED_MODULE_3__[\"proto\"].MethodType.UNSUBSCRIBE,\r\n                params: {\r\n                    channel: sub.channel\r\n                }\r\n            }).then(function (result) {\r\n                sub.setUnsubscribed();\r\n            }, function (error) {\r\n            });\r\n        }\r\n    };\r\n    Centrifuge.prototype.addCommand = function (command) {\r\n        var _this = this;\r\n        return new Promise(function (callback, errback) {\r\n            var id = _this._getNextCommandId();\r\n            command.id = id;\r\n            if (_this._isBatching === true) {\r\n                _this._commands.push(command);\r\n            }\r\n            else {\r\n                _this._send([command]);\r\n            }\r\n            _this._callbacks[id] = {\r\n                callback: callback,\r\n                errback: errback,\r\n            };\r\n            setTimeout(function () {\r\n                delete _this._callbacks[id];\r\n                if (Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(errback)) {\r\n                    errback({\r\n                        message: 'Timeout',\r\n                    });\r\n                }\r\n            }, _this._config.timeout);\r\n        });\r\n    };\r\n    Centrifuge.log = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        _Functions__WEBPACK_IMPORTED_MODULE_0__[\"log\"].apply(void 0, ['info'].concat(args));\r\n    };\r\n    Centrifuge.error = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        _Functions__WEBPACK_IMPORTED_MODULE_0__[\"log\"].apply(void 0, ['error'].concat(args));\r\n    };\r\n    Centrifuge.prototype._debug = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (this._config.debug === true) {\r\n            _Functions__WEBPACK_IMPORTED_MODULE_0__[\"log\"].apply(void 0, ['debug'].concat(args));\r\n        }\r\n    };\r\n    Centrifuge.prototype._configure = function (config) {\r\n        this._debug('Configuring Centrifuge with', config);\r\n        config = Object.assign({\r\n            retry: 1000,\r\n            maxRetry: 20000,\r\n            timeout: 5000,\r\n            info: '',\r\n            resubscribe: true,\r\n            ping: true,\r\n            pingInterval: 30000,\r\n            pongWaitTimeout: 5000,\r\n            debug: false,\r\n            insecure: false,\r\n            privateChannelPrefix: '$',\r\n            refreshEndpoint: '/centrifuge/refresh/',\r\n            refreshHeaders: {},\r\n            refreshParams: {},\r\n            refreshData: {},\r\n            refreshAttempts: 0,\r\n            refreshInterval: 3000,\r\n            authEndpoint: '/centrifuge/auth/',\r\n            authHeaders: {},\r\n            authParams: {},\r\n        }, config);\r\n        if (!config.url) {\r\n            throw new Error('Missing required configuration parameter \\'url\\' specifying server URL');\r\n        }\r\n        config.url = Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"stripSlash\"])(config.url);\r\n        if (Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(config.sockJS)) {\r\n            this._isSockJS = true;\r\n            if (!config.transports || !config.transports.length) {\r\n                config.transports = [\r\n                    'websocket',\r\n                    'xdr-streaming',\r\n                    'xhr-streaming',\r\n                    'eventsource',\r\n                    'iframe-eventsource',\r\n                    'iframe-htmlfile',\r\n                    'xdr-polling',\r\n                    'xhr-polling',\r\n                    'iframe-xhr-polling',\r\n                    'jsonp-polling'\r\n                ];\r\n            }\r\n        }\r\n        else {\r\n            if (!Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(WebSocket)) {\r\n                throw new Error('No Websocket support and no SockJS configured, can not connect');\r\n            }\r\n        }\r\n        if (!config.user) {\r\n            if (!config.insecure) {\r\n                throw new Error('Missing required configuration parameter \\'user\\' specifying user\\'s unique ID in your application');\r\n            }\r\n            else {\r\n                this._debug('Configuration parameter \\'user\\' not found but this is OK for insecure mode - anonymous access will be used');\r\n            }\r\n        }\r\n        else {\r\n            if (!Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(config.user)) {\r\n                Centrifuge.log('Configuration parameter \\'user\\' expected to be string');\r\n            }\r\n        }\r\n        if (!config.exp) {\r\n            if (!config.insecure) {\r\n                throw new Error('Missing required configuration parameter \\'time\\'');\r\n            }\r\n            else {\r\n                this._debug('Configuration parameter \\'exp\\' not found but this is OK for insecure mode');\r\n            }\r\n        }\r\n        else {\r\n            if (!Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(config.exp)) {\r\n                Centrifuge.log('Configuration parameter \\'exp\\' expected to be string');\r\n            }\r\n        }\r\n        if (!config.sign) {\r\n            if (!config.insecure) {\r\n                throw new Error('Missing required configuration parameter \\'sign\\' specifying the sign of authorization request');\r\n            }\r\n            else {\r\n                this._debug('Configuration parameter \\'sign\\' not found but this is OK for insecure mode');\r\n            }\r\n        }\r\n        else {\r\n            if (!Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(config.sign)) {\r\n                Centrifuge.log('Configuration parameter \\'sign\\' expected to be string');\r\n            }\r\n        }\r\n        if (config.info && !Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(config.info)) {\r\n            Centrifuge.log('Configuration parameter \\'info\\' expected to be string');\r\n        }\r\n        this._config = config;\r\n    };\r\n    Centrifuge.prototype._request = function (url, params, headers, data, callback) {\r\n        this._debug('Sending POST request to', url);\r\n        var query = Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"objectToQuery\"])(params);\r\n        if (query.length > 0) {\r\n            query = '?' + query;\r\n        }\r\n        var _headers = new Headers();\r\n        _headers.append('X-Requested-With', 'XMLHttpRequest');\r\n        _headers.append('Content-Type', 'application/json');\r\n        for (var headerName in headers) {\r\n            if (headers.hasOwnProperty(headerName)) {\r\n                _headers.append(headerName, headers[headerName]);\r\n            }\r\n        }\r\n        fetch(url + query, {\r\n            method: 'POST',\r\n            headers: _headers,\r\n            body: data,\r\n            credentials: 'include',\r\n            mode: 'cors',\r\n        }).then(function (response) {\r\n            if (response.ok) {\r\n                return response.json();\r\n            }\r\n            Centrifuge.error('Network response was not ok', response.status);\r\n        }).then(function (callbackData) {\r\n            callback(false, callbackData);\r\n        }).catch(function (error) {\r\n            Centrifuge.error('Network response error', error);\r\n        });\r\n    };\r\n    Centrifuge.prototype._getSockjsEndpoint = function () {\r\n        var url = this._config.url;\r\n        url = url\r\n            .replace('ws://', 'http://')\r\n            .replace('wss://', 'https://');\r\n        url = Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"stripSlash\"])(url);\r\n        if (!Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"endsWith\"])(this._config.url, 'connection')) {\r\n            url = url + '/connection';\r\n        }\r\n        return url;\r\n    };\r\n    Centrifuge.prototype._getWebsocketEndpoint = function () {\r\n        var url = this._config.url;\r\n        url = url\r\n            .replace('http://', 'ws://')\r\n            .replace('https://', 'wss://');\r\n        url = Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"stripSlash\"])(url);\r\n        if (!Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"endsWith\"])(this._config.url, 'connection/websocket')) {\r\n            url = url + '/connection/websocket';\r\n        }\r\n        return url;\r\n    };\r\n    Centrifuge.prototype._recover = function (channel) {\r\n        return channel in this._lastMessageID;\r\n    };\r\n    Centrifuge.prototype._getLastID = function (channel) {\r\n        var lastUID = this._lastMessageID[channel];\r\n        if (lastUID) {\r\n            this._debug('Last uid found and sent for channel', channel);\r\n            return lastUID;\r\n        }\r\n        else {\r\n            this._debug('No last uid found for channel', channel);\r\n            return '';\r\n        }\r\n    };\r\n    Centrifuge.prototype._getSub = function (channel) {\r\n        return this._subs[channel] || null;\r\n    };\r\n    Centrifuge.prototype._clearConnectedState = function (reconnect) {\r\n        this._clientID = null;\r\n        for (var uid in this._callbacks) {\r\n            if (this._callbacks.hasOwnProperty(uid)) {\r\n                var callbacks = this._callbacks[uid];\r\n                var errback = callbacks.errback;\r\n                if (Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(errback)) {\r\n                    errback({\r\n                        message: 'Disconnected',\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        this._callbacks = {};\r\n        for (var channel in this._subs) {\r\n            if (this._subs.hasOwnProperty(channel)) {\r\n                var sub = this._getSub(channel);\r\n                if (reconnect) {\r\n                    if (sub.isSuccess) {\r\n                        sub.triggerUnsubscribe();\r\n                    }\r\n                    sub.setSubscribing();\r\n                }\r\n                else {\r\n                    sub.setUnsubscribed();\r\n                }\r\n            }\r\n        }\r\n        if (!this._config.resubscribe || !this._reconnect) {\r\n            this._subs = {};\r\n        }\r\n    };\r\n    Centrifuge.prototype._setStatus = function (status) {\r\n        if (this._status !== status) {\r\n            this._debug('Status:', this._status, '->', status);\r\n            this._status = status;\r\n        }\r\n    };\r\n    Centrifuge.prototype._disconnect = function (reason, shouldReconnect) {\r\n        if (shouldReconnect === void 0) { shouldReconnect = false; }\r\n        if (this.isDisconnected) {\r\n            return;\r\n        }\r\n        this._debug('Disconnected:', reason + '.', 'shouldReconnect:', shouldReconnect);\r\n        if (shouldReconnect === false) {\r\n            this._reconnect = false;\r\n        }\r\n        this._clearConnectedState(shouldReconnect);\r\n        if (!this.isDisconnected) {\r\n            this._setStatus('disconnected');\r\n            if (this._refreshTimeout) {\r\n                clearTimeout(this._refreshTimeout);\r\n            }\r\n            if (this._reconnecting === false) {\r\n                this.trigger('disconnect', [{\r\n                        reason: reason,\r\n                        reconnect: shouldReconnect,\r\n                    }]);\r\n            }\r\n        }\r\n        if (!this._transportClosed) {\r\n            this._transport.close();\r\n        }\r\n    };\r\n    Centrifuge.prototype._send = function (commands) {\r\n        if (!commands.length) {\r\n            return;\r\n        }\r\n        var encodedCommands = [];\r\n        for (var i in commands) {\r\n            if (commands.hasOwnProperty(i)) {\r\n                encodedCommands.push(JSON.stringify(commands[i]));\r\n            }\r\n        }\r\n        this._transport.send(encodedCommands.join(\"\\n\"));\r\n        this._debug('Send', commands);\r\n    };\r\n    Centrifuge.prototype._getNextCommandId = function () {\r\n        return ++this._commandId;\r\n    };\r\n    Centrifuge.prototype._stopPing = function () {\r\n        if (this._pongTimeout !== null) {\r\n            clearTimeout(this._pongTimeout);\r\n        }\r\n        if (this._pingInterval !== null) {\r\n            clearInterval(this._pingInterval);\r\n        }\r\n    };\r\n    Centrifuge.prototype._startPing = function () {\r\n        var _this = this;\r\n        if (this._config.ping !== true || this._config.pingInterval <= 0 || !this.isConnected) {\r\n            return;\r\n        }\r\n        this._pingInterval = setInterval(function () {\r\n            if (!_this.isConnected) {\r\n                _this._stopPing();\r\n                return;\r\n            }\r\n            _this.ping();\r\n            _this._pongTimeout = setTimeout(function () {\r\n                this._disconnect('no ping', true);\r\n            }, _this._config.pongWaitTimeout);\r\n        }, this._config.pingInterval);\r\n    };\r\n    Centrifuge.prototype._restartPing = function () {\r\n        this._stopPing();\r\n        this._startPing();\r\n    };\r\n    Centrifuge.prototype._resetRetry = function () {\r\n        this._debug('Reset retries count to 0');\r\n        this._retries = 0;\r\n    };\r\n    Centrifuge.prototype._getRetryInterval = function () {\r\n        this._retries += 1;\r\n        var jitter = 0.5 * Math.random();\r\n        var interval = this._config.retry * Math.pow(2, this._retries + 1);\r\n        if (interval > this._config.maxRetry) {\r\n            interval = this._config.maxRetry;\r\n        }\r\n        return Math.floor((1 - jitter) * interval);\r\n    };\r\n    Centrifuge.prototype._refreshFailed = function () {\r\n        this._numRefreshFailed = 0;\r\n        if (!this.isDisconnected) {\r\n            this._disconnect('refresh failed');\r\n        }\r\n        if (this._config.refreshFailed) {\r\n            this._config.refreshFailed();\r\n        }\r\n    };\r\n    Centrifuge.prototype._refresh = function () {\r\n        var _this = this;\r\n        this._debug('Refresh credentials');\r\n        if (this._config.refreshAttempts === 0) {\r\n            this._debug('Refresh attempts set to 0, do not send refresh request at all');\r\n            this._refreshFailed();\r\n            return;\r\n        }\r\n        if (this._refreshTimeout !== null) {\r\n            clearTimeout(this._refreshTimeout);\r\n        }\r\n        var cb = function (err, data) {\r\n            if (err === true) {\r\n                _this._debug('Error getting connection credentials from refresh endpoint', data);\r\n                _this._numRefreshFailed++;\r\n                if (_this._refreshTimeout) {\r\n                    clearTimeout(_this._refreshTimeout);\r\n                }\r\n                if (_this._config.refreshAttempts !== null && _this._numRefreshFailed >= _this._config.refreshAttempts) {\r\n                    _this._refreshFailed();\r\n                    return;\r\n                }\r\n                _this._refreshTimeout = setTimeout(function () {\r\n                    _this._refresh();\r\n                }, _this._config.refreshInterval + Math.round(Math.random() * 1000));\r\n                return;\r\n            }\r\n            _this._numRefreshFailed = 0;\r\n            _this._config.user = data.user;\r\n            _this._config.exp = data.exp;\r\n            _this._config.sign = data.sign;\r\n            if ('info' in data) {\r\n                _this._config.info = data.info;\r\n            }\r\n            else {\r\n                data.info = '';\r\n            }\r\n            if (_this.isDisconnected) {\r\n                _this._debug('Credentials refreshed, connect from scratch');\r\n                _this.connect();\r\n            }\r\n            else {\r\n                _this._debug('Send refreshed credentials');\r\n                _this.addCommand({\r\n                    method: _Proto__WEBPACK_IMPORTED_MODULE_3__[\"proto\"].MethodType.REFRESH,\r\n                    params: data,\r\n                }).then(function (result) {\r\n                    _this._refreshResult(result);\r\n                }, function (error) {\r\n                });\r\n            }\r\n        };\r\n        if (this._config.onRefresh !== null) {\r\n            this._config.onRefresh({}, cb);\r\n        }\r\n        else {\r\n            this._request(this._config.refreshEndpoint, this._config.refreshParams, this._config.refreshHeaders, this._config.refreshData, cb);\r\n        }\r\n    };\r\n    Centrifuge.prototype._connectResult = function (result) {\r\n        var _this = this;\r\n        if (this.isConnected) {\r\n            return;\r\n        }\r\n        if (this._latencyStart !== null) {\r\n            this._latency = (new Date()).getTime() - this._latencyStart.getTime();\r\n            this._latencyStart = null;\r\n        }\r\n        if (result.expires) {\r\n            if (result.expired) {\r\n                this._reconnecting = true;\r\n                this._disconnect('expired', true);\r\n                this._refresh();\r\n                return;\r\n            }\r\n        }\r\n        this._clientID = result.client;\r\n        this._setStatus('connected');\r\n        if (this._refreshTimeout) {\r\n            clearTimeout(this._refreshTimeout);\r\n        }\r\n        if (result.expires) {\r\n            this._refreshTimeout = setTimeout(function () {\r\n                _this._refresh();\r\n            }, result.ttl * 1000);\r\n        }\r\n        if (this._config.resubscribe) {\r\n            this.startBatching();\r\n            this.startAuthBatching();\r\n            for (var channel in this._subs) {\r\n                if (this._subs.hasOwnProperty(channel)) {\r\n                    var sub = this._getSub(channel);\r\n                    if (sub.shouldResubscribe()) {\r\n                        this.subscribeSub(sub);\r\n                    }\r\n                }\r\n            }\r\n            this.stopAuthBatching();\r\n            this.stopBatching(true);\r\n        }\r\n        this._restartPing();\r\n        this.trigger('connect', [{\r\n                version: result.version,\r\n                client: result.client,\r\n                transport: this._transportName,\r\n                latency: this._latency\r\n            }]);\r\n    };\r\n    Centrifuge.prototype._subscribeResult = function (result, channel) {\r\n        var sub = this._getSub(channel);\r\n        if (!sub || !sub.isSubscribing) {\r\n            return;\r\n        }\r\n        var publications = result.publications;\r\n        if (publications && publications.length) {\r\n            publications = publications.reverse();\r\n            for (var i in publications) {\r\n                if (publications.hasOwnProperty(i)) {\r\n                    this._messageResult({\r\n                        body: publications[i]\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if ('last' in result) {\r\n                this._lastMessageID[channel] = result.last;\r\n            }\r\n        }\r\n        sub.setSubscribeSuccess(result.recovered || false);\r\n    };\r\n    Centrifuge.prototype._subscribeError = function (error, channel) {\r\n        var sub = this._getSub(channel);\r\n        if (!sub || !sub.isSubscribing) {\r\n            return;\r\n        }\r\n        this.trigger('error', [{\r\n                error: error,\r\n            }]);\r\n        sub.setSubscribeError(error);\r\n    };\r\n    Centrifuge.prototype._joinResult = function (result) {\r\n    };\r\n    Centrifuge.prototype._leaveResult = function (result) {\r\n    };\r\n    Centrifuge.prototype._refreshResult = function (result) {\r\n        var _this = this;\r\n        if (this._refreshTimeout) {\r\n            clearTimeout(this._refreshTimeout);\r\n        }\r\n        if (result.expires) {\r\n            if (result.expired) {\r\n                this._refreshTimeout = setTimeout(function () {\r\n                    _this._refresh();\r\n                }, this._config.refreshInterval + Math.round(Math.random() * 1000));\r\n                return;\r\n            }\r\n            this._clientID = result.client;\r\n            this._refreshTimeout = setTimeout(function () {\r\n                _this._refresh();\r\n            }, result.ttl * 1000);\r\n        }\r\n    };\r\n    Centrifuge.prototype._messageResult = function (message) {\r\n        var body = message.body;\r\n        var channel = body.channel;\r\n        this._lastMessageID[channel] = body.uid;\r\n        var sub = this._getSub(channel);\r\n        if (!sub) {\r\n            return;\r\n        }\r\n        sub.trigger('message', [body]);\r\n    };\r\n    Centrifuge.prototype._handleReply = function (reply) {\r\n        var id = reply.id;\r\n        if (!(id in this._callbacks)) {\r\n            return;\r\n        }\r\n        var callbacks = this._callbacks[id];\r\n        delete this._callbacks[id];\r\n        if (!Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"errorExists\"])(reply)) {\r\n            var callback = callbacks.callback;\r\n            if (Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(callback)) {\r\n                callback(reply.result);\r\n            }\r\n        }\r\n        else {\r\n            var errback = callbacks.errback;\r\n            if (Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(errback)) {\r\n                errback(reply.error);\r\n            }\r\n            this.trigger('error', [reply.error]);\r\n        }\r\n    };\r\n    Centrifuge.prototype._dispatchMessage = function (message) {\r\n        if (message === undefined || message === null) {\r\n            this._debug('Dispatch: got undefined or null message');\r\n            return;\r\n        }\r\n        switch (message.method) {\r\n            case 'join':\r\n                this._joinResult(message);\r\n                break;\r\n            case 'leave':\r\n                this._leaveResult(message);\r\n                break;\r\n            case 'message':\r\n                this._messageResult(message);\r\n                break;\r\n            default:\r\n                this._handleReply(message);\r\n        }\r\n    };\r\n    Centrifuge.prototype._receive = function (data) {\r\n        if (Object.prototype.toString.call(data) === Object.prototype.toString.call([])) {\r\n            for (var i in data) {\r\n                if (data.hasOwnProperty(i)) {\r\n                    this._dispatchMessage(data[i]);\r\n                }\r\n            }\r\n        }\r\n        else if (Object.prototype.toString.call(data) === Object.prototype.toString.call({})) {\r\n            this._dispatchMessage(data);\r\n        }\r\n    };\r\n    Centrifuge.prototype._setTransport = function () {\r\n        var _this = this;\r\n        if (this._isSockJS) {\r\n            var sockjsOptions = {\r\n                transports: this._config.transports\r\n            };\r\n            if (this._config.server) {\r\n                sockjsOptions.server = this._config.server;\r\n            }\r\n            this._transport = new this._config.sockJS(this._getSockjsEndpoint(), null, sockjsOptions);\r\n        }\r\n        else {\r\n            this._transport = new WebSocket(this._getWebsocketEndpoint());\r\n        }\r\n        this._transport.onopen = function () {\r\n            _this._transportClosed = false;\r\n            _this._reconnecting = false;\r\n            if (_this._isSockJS) {\r\n                _this._transportName = _this._transport.transport;\r\n                _this._transport.onheartbeat = function () {\r\n                    _this._restartPing();\r\n                };\r\n            }\r\n            else {\r\n                _this._transportName = 'raw-websocket';\r\n            }\r\n            _this._resetRetry();\r\n            var msg = {\r\n                method: _Proto__WEBPACK_IMPORTED_MODULE_3__[\"proto\"].MethodType.CONNECT,\r\n                params: {\r\n                    user: _this._config.user,\r\n                    info: _this._config.info,\r\n                }\r\n            };\r\n            if (!_this._config.insecure) {\r\n                msg.params.exp = _this._config.exp;\r\n                msg.params.sign = _this._config.sign;\r\n            }\r\n            _this._latencyStart = new Date();\r\n            _this.addCommand(msg).then(function (result) {\r\n                _this._connectResult(result);\r\n            }, function (error) {\r\n            });\r\n        };\r\n        this._transport.onerror = function (error) {\r\n            _this._debug('Transport level error', error);\r\n        };\r\n        this._transport.onclose = function (event) {\r\n            _this._transportClosed = true;\r\n            var reason = 'Connection closed';\r\n            var reconnect = true;\r\n            if (event && 'reason' in event && event.reason) {\r\n                try {\r\n                    var advice = JSON.parse(event.reason);\r\n                    _this._debug(reason + '. Reason is an advice object:', advice);\r\n                    reason = advice.reason;\r\n                    reconnect = advice.reconnect;\r\n                }\r\n                catch (e) {\r\n                    reason = event.reason;\r\n                    _this._debug(reason + '. Reason is a plain string:', reason);\r\n                    reconnect = reason !== 'disconnect';\r\n                }\r\n            }\r\n            if (_this._config.onTransportClose) {\r\n                _this._config.onTransportClose({\r\n                    event: event,\r\n                    reason: reason,\r\n                    reconnect: reconnect,\r\n                });\r\n            }\r\n            _this._disconnect(reason, reconnect);\r\n            if (_this._reconnect === true) {\r\n                _this._reconnecting = true;\r\n                var interval = _this._getRetryInterval();\r\n                _this._debug('Reconnect after ' + interval + ' milliseconds');\r\n                setTimeout(function () {\r\n                    if (_this._reconnect === true) {\r\n                        _this.connect();\r\n                    }\r\n                }, interval);\r\n            }\r\n        };\r\n        this._transport.onmessage = function (event) {\r\n            var replies = event.data.split(\"\\n\");\r\n            for (var i in replies) {\r\n                if (!replies[i]) {\r\n                    continue;\r\n                }\r\n                var data = JSON.parse(replies[i]);\r\n                _this._debug('Received', data);\r\n                _this._receive(data);\r\n            }\r\n            _this._restartPing();\r\n        };\r\n    };\r\n    return Centrifuge;\r\n}(js_observable__WEBPACK_IMPORTED_MODULE_1__[\"Observable\"]));\r\n\r\n\n\n//# sourceURL=webpack:///./src/Centrifuge.ts?")},"./src/Functions.ts":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isFunction\", function() { return isFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isString\", function() { return isString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"log\", function() { return log; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stripSlash\", function() { return stripSlash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"startsWith\", function() { return startsWith; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"endsWith\", function() { return endsWith; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"errorExists\", function() { return errorExists; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"objectToQuery\", function() { return objectToQuery; });\nvar isFunction = function (value) {\r\n    return typeof value === 'function';\r\n};\r\nvar isString = function (value) {\r\n    return typeof value === 'string';\r\n};\r\nvar log = function (level) {\r\n    var args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        args[_i - 1] = arguments[_i];\r\n    }\r\n    if (console) {\r\n        var logger = console[level];\r\n        if (isFunction(logger)) {\r\n            logger.apply(logger, args);\r\n        }\r\n    }\r\n};\r\nvar stripSlash = function (value) {\r\n    return value.replace(/\\/$/, '');\r\n};\r\nvar startsWith = function (value, prefix) {\r\n    return value.lastIndexOf(prefix, 0) === 0;\r\n};\r\nvar endsWith = function (value, suffix) {\r\n    return value.indexOf(suffix, value.length - suffix.length) !== -1;\r\n};\r\nvar errorExists = function (data) {\r\n    return 'error' in data && data.error !== null && data.error !== '';\r\n};\r\nvar objectToQuery = function (object) {\r\n    var p = [];\r\n    for (var i in object) {\r\n        if (object.hasOwnProperty(i)) {\r\n            p.push(encodeURIComponent(i) + (object[i] ? '=' + encodeURIComponent(object[i]) : ''));\r\n        }\r\n    }\r\n    return p.join('&');\r\n};\r\n\n\n//# sourceURL=webpack:///./src/Functions.ts?")},"./src/Proto.js":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/\n(function(global, factory) { /* global define, require, module */\n\n    /* AMD */ if (true)\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /* CommonJS */ else {}\n\n})(this, function($protobuf) {\n    "use strict";\n\n    // Common aliases\n    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n    \n    // Exported root namespace\n    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});\n    \n    $root.proto = (function() {\n    \n        /**\n         * Namespace proto.\n         * @exports proto\n         * @namespace\n         */\n        var proto = {};\n    \n        proto.Error = (function() {\n    \n            /**\n             * Properties of an Error.\n             * @memberof proto\n             * @interface IError\n             * @property {number|null} [code] Error code\n             * @property {string|null} [message] Error message\n             */\n    \n            /**\n             * Constructs a new Error.\n             * @memberof proto\n             * @classdesc Represents an Error.\n             * @implements IError\n             * @constructor\n             * @param {proto.IError=} [properties] Properties to set\n             */\n            function Error(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * Error code.\n             * @member {number} code\n             * @memberof proto.Error\n             * @instance\n             */\n            Error.prototype.code = 0;\n    \n            /**\n             * Error message.\n             * @member {string} message\n             * @memberof proto.Error\n             * @instance\n             */\n            Error.prototype.message = "";\n    \n            /**\n             * Creates a new Error instance using the specified properties.\n             * @function create\n             * @memberof proto.Error\n             * @static\n             * @param {proto.IError=} [properties] Properties to set\n             * @returns {proto.Error} Error instance\n             */\n            Error.create = function create(properties) {\n                return new Error(properties);\n            };\n    \n            /**\n             * Encodes the specified Error message. Does not implicitly {@link proto.Error.verify|verify} messages.\n             * @function encode\n             * @memberof proto.Error\n             * @static\n             * @param {proto.IError} message Error message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Error.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.code != null && message.hasOwnProperty("code"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.code);\n                if (message.message != null && message.hasOwnProperty("message"))\n                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified Error message, length delimited. Does not implicitly {@link proto.Error.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.Error\n             * @static\n             * @param {proto.IError} message Error message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Error.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes an Error message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.Error\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.Error} Error\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Error.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Error();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.code = reader.uint32();\n                        break;\n                    case 2:\n                        message.message = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes an Error message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.Error\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.Error} Error\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Error.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies an Error message.\n             * @function verify\n             * @memberof proto.Error\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Error.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.code != null && message.hasOwnProperty("code"))\n                    if (!$util.isInteger(message.code))\n                        return "code: integer expected";\n                if (message.message != null && message.hasOwnProperty("message"))\n                    if (!$util.isString(message.message))\n                        return "message: string expected";\n                return null;\n            };\n    \n            /**\n             * Creates an Error message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.Error\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.Error} Error\n             */\n            Error.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.Error)\n                    return object;\n                var message = new $root.proto.Error();\n                if (object.code != null)\n                    message.code = object.code >>> 0;\n                if (object.message != null)\n                    message.message = String(object.message);\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from an Error message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.Error\n             * @static\n             * @param {proto.Error} message Error\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Error.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.code = 0;\n                    object.message = "";\n                }\n                if (message.code != null && message.hasOwnProperty("code"))\n                    object.code = message.code;\n                if (message.message != null && message.hasOwnProperty("message"))\n                    object.message = message.message;\n                return object;\n            };\n    \n            /**\n             * Converts this Error to JSON.\n             * @function toJSON\n             * @memberof proto.Error\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Error.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return Error;\n        })();\n    \n        /**\n         * MethodType enum.\n         * @name proto.MethodType\n         * @enum {string}\n         * @property {number} CONNECT=0 CONNECT value\n         * @property {number} REFRESH=1 REFRESH value\n         * @property {number} SUBSCRIBE=2 SUBSCRIBE value\n         * @property {number} UNSUBSCRIBE=3 UNSUBSCRIBE value\n         * @property {number} PUBLISH=4 PUBLISH value\n         * @property {number} PRESENCE=5 PRESENCE value\n         * @property {number} PRESENCE_STATS=6 PRESENCE_STATS value\n         * @property {number} HISTORY=7 HISTORY value\n         * @property {number} PING=8 PING value\n         * @property {number} RPC=9 RPC value\n         * @property {number} MESSAGE=10 MESSAGE value\n         */\n        proto.MethodType = (function() {\n            var valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = "CONNECT"] = 0;\n            values[valuesById[1] = "REFRESH"] = 1;\n            values[valuesById[2] = "SUBSCRIBE"] = 2;\n            values[valuesById[3] = "UNSUBSCRIBE"] = 3;\n            values[valuesById[4] = "PUBLISH"] = 4;\n            values[valuesById[5] = "PRESENCE"] = 5;\n            values[valuesById[6] = "PRESENCE_STATS"] = 6;\n            values[valuesById[7] = "HISTORY"] = 7;\n            values[valuesById[8] = "PING"] = 8;\n            values[valuesById[9] = "RPC"] = 9;\n            values[valuesById[10] = "MESSAGE"] = 10;\n            return values;\n        })();\n    \n        proto.Command = (function() {\n    \n            /**\n             * Properties of a Command.\n             * @memberof proto\n             * @interface ICommand\n             * @property {number|null} [id] Command id\n             * @property {proto.MethodType|null} [method] Command method\n             * @property {Uint8Array|null} [params] Command params\n             */\n    \n            /**\n             * Constructs a new Command.\n             * @memberof proto\n             * @classdesc Represents a Command.\n             * @implements ICommand\n             * @constructor\n             * @param {proto.ICommand=} [properties] Properties to set\n             */\n            function Command(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * Command id.\n             * @member {number} id\n             * @memberof proto.Command\n             * @instance\n             */\n            Command.prototype.id = 0;\n    \n            /**\n             * Command method.\n             * @member {proto.MethodType} method\n             * @memberof proto.Command\n             * @instance\n             */\n            Command.prototype.method = 0;\n    \n            /**\n             * Command params.\n             * @member {Uint8Array} params\n             * @memberof proto.Command\n             * @instance\n             */\n            Command.prototype.params = $util.newBuffer([]);\n    \n            /**\n             * Creates a new Command instance using the specified properties.\n             * @function create\n             * @memberof proto.Command\n             * @static\n             * @param {proto.ICommand=} [properties] Properties to set\n             * @returns {proto.Command} Command instance\n             */\n            Command.create = function create(properties) {\n                return new Command(properties);\n            };\n    \n            /**\n             * Encodes the specified Command message. Does not implicitly {@link proto.Command.verify|verify} messages.\n             * @function encode\n             * @memberof proto.Command\n             * @static\n             * @param {proto.ICommand} message Command message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Command.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.id != null && message.hasOwnProperty("id"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);\n                if (message.method != null && message.hasOwnProperty("method"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.method);\n                if (message.params != null && message.hasOwnProperty("params"))\n                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.params);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified Command message, length delimited. Does not implicitly {@link proto.Command.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.Command\n             * @static\n             * @param {proto.ICommand} message Command message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Command.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a Command message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.Command\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.Command} Command\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Command.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Command();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.id = reader.uint32();\n                        break;\n                    case 2:\n                        message.method = reader.int32();\n                        break;\n                    case 3:\n                        message.params = reader.bytes();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a Command message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.Command\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.Command} Command\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Command.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a Command message.\n             * @function verify\n             * @memberof proto.Command\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Command.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.id != null && message.hasOwnProperty("id"))\n                    if (!$util.isInteger(message.id))\n                        return "id: integer expected";\n                if (message.method != null && message.hasOwnProperty("method"))\n                    switch (message.method) {\n                    default:\n                        return "method: enum value expected";\n                    case 0:\n                    case 1:\n                    case 2:\n                    case 3:\n                    case 4:\n                    case 5:\n                    case 6:\n                    case 7:\n                    case 8:\n                    case 9:\n                    case 10:\n                        break;\n                    }\n                if (message.params != null && message.hasOwnProperty("params"))\n                    if (!(message.params && typeof message.params.length === "number" || $util.isString(message.params)))\n                        return "params: buffer expected";\n                return null;\n            };\n    \n            /**\n             * Creates a Command message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.Command\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.Command} Command\n             */\n            Command.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.Command)\n                    return object;\n                var message = new $root.proto.Command();\n                if (object.id != null)\n                    message.id = object.id >>> 0;\n                switch (object.method) {\n                case "CONNECT":\n                case 0:\n                    message.method = 0;\n                    break;\n                case "REFRESH":\n                case 1:\n                    message.method = 1;\n                    break;\n                case "SUBSCRIBE":\n                case 2:\n                    message.method = 2;\n                    break;\n                case "UNSUBSCRIBE":\n                case 3:\n                    message.method = 3;\n                    break;\n                case "PUBLISH":\n                case 4:\n                    message.method = 4;\n                    break;\n                case "PRESENCE":\n                case 5:\n                    message.method = 5;\n                    break;\n                case "PRESENCE_STATS":\n                case 6:\n                    message.method = 6;\n                    break;\n                case "HISTORY":\n                case 7:\n                    message.method = 7;\n                    break;\n                case "PING":\n                case 8:\n                    message.method = 8;\n                    break;\n                case "RPC":\n                case 9:\n                    message.method = 9;\n                    break;\n                case "MESSAGE":\n                case 10:\n                    message.method = 10;\n                    break;\n                }\n                if (object.params != null)\n                    if (typeof object.params === "string")\n                        $util.base64.decode(object.params, message.params = $util.newBuffer($util.base64.length(object.params)), 0);\n                    else if (object.params.length)\n                        message.params = object.params;\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a Command message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.Command\n             * @static\n             * @param {proto.Command} message Command\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Command.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.id = 0;\n                    object.method = options.enums === String ? "CONNECT" : 0;\n                    object.params = options.bytes === String ? "" : [];\n                }\n                if (message.id != null && message.hasOwnProperty("id"))\n                    object.id = message.id;\n                if (message.method != null && message.hasOwnProperty("method"))\n                    object.method = options.enums === String ? $root.proto.MethodType[message.method] : message.method;\n                if (message.params != null && message.hasOwnProperty("params"))\n                    object.params = options.bytes === String ? $util.base64.encode(message.params, 0, message.params.length) : options.bytes === Array ? Array.prototype.slice.call(message.params) : message.params;\n                return object;\n            };\n    \n            /**\n             * Converts this Command to JSON.\n             * @function toJSON\n             * @memberof proto.Command\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Command.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return Command;\n        })();\n    \n        proto.Reply = (function() {\n    \n            /**\n             * Properties of a Reply.\n             * @memberof proto\n             * @interface IReply\n             * @property {number|null} [id] Reply id\n             * @property {proto.IError|null} [error] Reply error\n             * @property {Uint8Array|null} [result] Reply result\n             */\n    \n            /**\n             * Constructs a new Reply.\n             * @memberof proto\n             * @classdesc Represents a Reply.\n             * @implements IReply\n             * @constructor\n             * @param {proto.IReply=} [properties] Properties to set\n             */\n            function Reply(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * Reply id.\n             * @member {number} id\n             * @memberof proto.Reply\n             * @instance\n             */\n            Reply.prototype.id = 0;\n    \n            /**\n             * Reply error.\n             * @member {proto.IError|null|undefined} error\n             * @memberof proto.Reply\n             * @instance\n             */\n            Reply.prototype.error = null;\n    \n            /**\n             * Reply result.\n             * @member {Uint8Array} result\n             * @memberof proto.Reply\n             * @instance\n             */\n            Reply.prototype.result = $util.newBuffer([]);\n    \n            /**\n             * Creates a new Reply instance using the specified properties.\n             * @function create\n             * @memberof proto.Reply\n             * @static\n             * @param {proto.IReply=} [properties] Properties to set\n             * @returns {proto.Reply} Reply instance\n             */\n            Reply.create = function create(properties) {\n                return new Reply(properties);\n            };\n    \n            /**\n             * Encodes the specified Reply message. Does not implicitly {@link proto.Reply.verify|verify} messages.\n             * @function encode\n             * @memberof proto.Reply\n             * @static\n             * @param {proto.IReply} message Reply message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Reply.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.id != null && message.hasOwnProperty("id"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);\n                if (message.error != null && message.hasOwnProperty("error"))\n                    $root.proto.Error.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                if (message.result != null && message.hasOwnProperty("result"))\n                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.result);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified Reply message, length delimited. Does not implicitly {@link proto.Reply.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.Reply\n             * @static\n             * @param {proto.IReply} message Reply message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Reply.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a Reply message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.Reply\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.Reply} Reply\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Reply.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Reply();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.id = reader.uint32();\n                        break;\n                    case 2:\n                        message.error = $root.proto.Error.decode(reader, reader.uint32());\n                        break;\n                    case 3:\n                        message.result = reader.bytes();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a Reply message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.Reply\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.Reply} Reply\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Reply.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a Reply message.\n             * @function verify\n             * @memberof proto.Reply\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Reply.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.id != null && message.hasOwnProperty("id"))\n                    if (!$util.isInteger(message.id))\n                        return "id: integer expected";\n                if (message.error != null && message.hasOwnProperty("error")) {\n                    var error = $root.proto.Error.verify(message.error);\n                    if (error)\n                        return "error." + error;\n                }\n                if (message.result != null && message.hasOwnProperty("result"))\n                    if (!(message.result && typeof message.result.length === "number" || $util.isString(message.result)))\n                        return "result: buffer expected";\n                return null;\n            };\n    \n            /**\n             * Creates a Reply message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.Reply\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.Reply} Reply\n             */\n            Reply.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.Reply)\n                    return object;\n                var message = new $root.proto.Reply();\n                if (object.id != null)\n                    message.id = object.id >>> 0;\n                if (object.error != null) {\n                    if (typeof object.error !== "object")\n                        throw TypeError(".proto.Reply.error: object expected");\n                    message.error = $root.proto.Error.fromObject(object.error);\n                }\n                if (object.result != null)\n                    if (typeof object.result === "string")\n                        $util.base64.decode(object.result, message.result = $util.newBuffer($util.base64.length(object.result)), 0);\n                    else if (object.result.length)\n                        message.result = object.result;\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a Reply message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.Reply\n             * @static\n             * @param {proto.Reply} message Reply\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Reply.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.id = 0;\n                    object.error = null;\n                    object.result = options.bytes === String ? "" : [];\n                }\n                if (message.id != null && message.hasOwnProperty("id"))\n                    object.id = message.id;\n                if (message.error != null && message.hasOwnProperty("error"))\n                    object.error = $root.proto.Error.toObject(message.error, options);\n                if (message.result != null && message.hasOwnProperty("result"))\n                    object.result = options.bytes === String ? $util.base64.encode(message.result, 0, message.result.length) : options.bytes === Array ? Array.prototype.slice.call(message.result) : message.result;\n                return object;\n            };\n    \n            /**\n             * Converts this Reply to JSON.\n             * @function toJSON\n             * @memberof proto.Reply\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Reply.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return Reply;\n        })();\n    \n        /**\n         * MessageType enum.\n         * @name proto.MessageType\n         * @enum {string}\n         * @property {number} PUBLICATION=0 PUBLICATION value\n         * @property {number} JOIN=1 JOIN value\n         * @property {number} LEAVE=2 LEAVE value\n         * @property {number} UNSUB=3 UNSUB value\n         */\n        proto.MessageType = (function() {\n            var valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = "PUBLICATION"] = 0;\n            values[valuesById[1] = "JOIN"] = 1;\n            values[valuesById[2] = "LEAVE"] = 2;\n            values[valuesById[3] = "UNSUB"] = 3;\n            return values;\n        })();\n    \n        proto.Message = (function() {\n    \n            /**\n             * Properties of a Message.\n             * @memberof proto\n             * @interface IMessage\n             * @property {proto.MessageType|null} [type] Message type\n             * @property {string|null} [channel] Message channel\n             * @property {Uint8Array|null} [data] Message data\n             */\n    \n            /**\n             * Constructs a new Message.\n             * @memberof proto\n             * @classdesc Represents a Message.\n             * @implements IMessage\n             * @constructor\n             * @param {proto.IMessage=} [properties] Properties to set\n             */\n            function Message(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * Message type.\n             * @member {proto.MessageType} type\n             * @memberof proto.Message\n             * @instance\n             */\n            Message.prototype.type = 0;\n    \n            /**\n             * Message channel.\n             * @member {string} channel\n             * @memberof proto.Message\n             * @instance\n             */\n            Message.prototype.channel = "";\n    \n            /**\n             * Message data.\n             * @member {Uint8Array} data\n             * @memberof proto.Message\n             * @instance\n             */\n            Message.prototype.data = $util.newBuffer([]);\n    \n            /**\n             * Creates a new Message instance using the specified properties.\n             * @function create\n             * @memberof proto.Message\n             * @static\n             * @param {proto.IMessage=} [properties] Properties to set\n             * @returns {proto.Message} Message instance\n             */\n            Message.create = function create(properties) {\n                return new Message(properties);\n            };\n    \n            /**\n             * Encodes the specified Message message. Does not implicitly {@link proto.Message.verify|verify} messages.\n             * @function encode\n             * @memberof proto.Message\n             * @static\n             * @param {proto.IMessage} message Message message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Message.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.type != null && message.hasOwnProperty("type"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.channel);\n                if (message.data != null && message.hasOwnProperty("data"))\n                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified Message message, length delimited. Does not implicitly {@link proto.Message.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.Message\n             * @static\n             * @param {proto.IMessage} message Message message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Message.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a Message message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.Message\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.Message} Message\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Message.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.type = reader.int32();\n                        break;\n                    case 2:\n                        message.channel = reader.string();\n                        break;\n                    case 3:\n                        message.data = reader.bytes();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a Message message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.Message\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.Message} Message\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Message.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a Message message.\n             * @function verify\n             * @memberof proto.Message\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Message.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.type != null && message.hasOwnProperty("type"))\n                    switch (message.type) {\n                    default:\n                        return "type: enum value expected";\n                    case 0:\n                    case 1:\n                    case 2:\n                    case 3:\n                        break;\n                    }\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    if (!$util.isString(message.channel))\n                        return "channel: string expected";\n                if (message.data != null && message.hasOwnProperty("data"))\n                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))\n                        return "data: buffer expected";\n                return null;\n            };\n    \n            /**\n             * Creates a Message message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.Message\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.Message} Message\n             */\n            Message.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.Message)\n                    return object;\n                var message = new $root.proto.Message();\n                switch (object.type) {\n                case "PUBLICATION":\n                case 0:\n                    message.type = 0;\n                    break;\n                case "JOIN":\n                case 1:\n                    message.type = 1;\n                    break;\n                case "LEAVE":\n                case 2:\n                    message.type = 2;\n                    break;\n                case "UNSUB":\n                case 3:\n                    message.type = 3;\n                    break;\n                }\n                if (object.channel != null)\n                    message.channel = String(object.channel);\n                if (object.data != null)\n                    if (typeof object.data === "string")\n                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);\n                    else if (object.data.length)\n                        message.data = object.data;\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a Message message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.Message\n             * @static\n             * @param {proto.Message} message Message\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Message.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.type = options.enums === String ? "PUBLICATION" : 0;\n                    object.channel = "";\n                    object.data = options.bytes === String ? "" : [];\n                }\n                if (message.type != null && message.hasOwnProperty("type"))\n                    object.type = options.enums === String ? $root.proto.MessageType[message.type] : message.type;\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    object.channel = message.channel;\n                if (message.data != null && message.hasOwnProperty("data"))\n                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;\n                return object;\n            };\n    \n            /**\n             * Converts this Message to JSON.\n             * @function toJSON\n             * @memberof proto.Message\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Message.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return Message;\n        })();\n    \n        proto.ClientInfo = (function() {\n    \n            /**\n             * Properties of a ClientInfo.\n             * @memberof proto\n             * @interface IClientInfo\n             * @property {string|null} [user] ClientInfo user\n             * @property {string|null} [client] ClientInfo client\n             * @property {Uint8Array|null} [connInfo] ClientInfo connInfo\n             * @property {Uint8Array|null} [chanInfo] ClientInfo chanInfo\n             */\n    \n            /**\n             * Constructs a new ClientInfo.\n             * @memberof proto\n             * @classdesc Represents a ClientInfo.\n             * @implements IClientInfo\n             * @constructor\n             * @param {proto.IClientInfo=} [properties] Properties to set\n             */\n            function ClientInfo(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * ClientInfo user.\n             * @member {string} user\n             * @memberof proto.ClientInfo\n             * @instance\n             */\n            ClientInfo.prototype.user = "";\n    \n            /**\n             * ClientInfo client.\n             * @member {string} client\n             * @memberof proto.ClientInfo\n             * @instance\n             */\n            ClientInfo.prototype.client = "";\n    \n            /**\n             * ClientInfo connInfo.\n             * @member {Uint8Array} connInfo\n             * @memberof proto.ClientInfo\n             * @instance\n             */\n            ClientInfo.prototype.connInfo = $util.newBuffer([]);\n    \n            /**\n             * ClientInfo chanInfo.\n             * @member {Uint8Array} chanInfo\n             * @memberof proto.ClientInfo\n             * @instance\n             */\n            ClientInfo.prototype.chanInfo = $util.newBuffer([]);\n    \n            /**\n             * Creates a new ClientInfo instance using the specified properties.\n             * @function create\n             * @memberof proto.ClientInfo\n             * @static\n             * @param {proto.IClientInfo=} [properties] Properties to set\n             * @returns {proto.ClientInfo} ClientInfo instance\n             */\n            ClientInfo.create = function create(properties) {\n                return new ClientInfo(properties);\n            };\n    \n            /**\n             * Encodes the specified ClientInfo message. Does not implicitly {@link proto.ClientInfo.verify|verify} messages.\n             * @function encode\n             * @memberof proto.ClientInfo\n             * @static\n             * @param {proto.IClientInfo} message ClientInfo message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ClientInfo.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.user != null && message.hasOwnProperty("user"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.user);\n                if (message.client != null && message.hasOwnProperty("client"))\n                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.client);\n                if (message.connInfo != null && message.hasOwnProperty("connInfo"))\n                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.connInfo);\n                if (message.chanInfo != null && message.hasOwnProperty("chanInfo"))\n                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.chanInfo);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified ClientInfo message, length delimited. Does not implicitly {@link proto.ClientInfo.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.ClientInfo\n             * @static\n             * @param {proto.IClientInfo} message ClientInfo message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ClientInfo.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a ClientInfo message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.ClientInfo\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.ClientInfo} ClientInfo\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ClientInfo.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientInfo();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.user = reader.string();\n                        break;\n                    case 2:\n                        message.client = reader.string();\n                        break;\n                    case 3:\n                        message.connInfo = reader.bytes();\n                        break;\n                    case 4:\n                        message.chanInfo = reader.bytes();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a ClientInfo message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.ClientInfo\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.ClientInfo} ClientInfo\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ClientInfo.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a ClientInfo message.\n             * @function verify\n             * @memberof proto.ClientInfo\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            ClientInfo.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.user != null && message.hasOwnProperty("user"))\n                    if (!$util.isString(message.user))\n                        return "user: string expected";\n                if (message.client != null && message.hasOwnProperty("client"))\n                    if (!$util.isString(message.client))\n                        return "client: string expected";\n                if (message.connInfo != null && message.hasOwnProperty("connInfo"))\n                    if (!(message.connInfo && typeof message.connInfo.length === "number" || $util.isString(message.connInfo)))\n                        return "connInfo: buffer expected";\n                if (message.chanInfo != null && message.hasOwnProperty("chanInfo"))\n                    if (!(message.chanInfo && typeof message.chanInfo.length === "number" || $util.isString(message.chanInfo)))\n                        return "chanInfo: buffer expected";\n                return null;\n            };\n    \n            /**\n             * Creates a ClientInfo message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.ClientInfo\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.ClientInfo} ClientInfo\n             */\n            ClientInfo.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.ClientInfo)\n                    return object;\n                var message = new $root.proto.ClientInfo();\n                if (object.user != null)\n                    message.user = String(object.user);\n                if (object.client != null)\n                    message.client = String(object.client);\n                if (object.connInfo != null)\n                    if (typeof object.connInfo === "string")\n                        $util.base64.decode(object.connInfo, message.connInfo = $util.newBuffer($util.base64.length(object.connInfo)), 0);\n                    else if (object.connInfo.length)\n                        message.connInfo = object.connInfo;\n                if (object.chanInfo != null)\n                    if (typeof object.chanInfo === "string")\n                        $util.base64.decode(object.chanInfo, message.chanInfo = $util.newBuffer($util.base64.length(object.chanInfo)), 0);\n                    else if (object.chanInfo.length)\n                        message.chanInfo = object.chanInfo;\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a ClientInfo message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.ClientInfo\n             * @static\n             * @param {proto.ClientInfo} message ClientInfo\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ClientInfo.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.user = "";\n                    object.client = "";\n                    object.connInfo = options.bytes === String ? "" : [];\n                    object.chanInfo = options.bytes === String ? "" : [];\n                }\n                if (message.user != null && message.hasOwnProperty("user"))\n                    object.user = message.user;\n                if (message.client != null && message.hasOwnProperty("client"))\n                    object.client = message.client;\n                if (message.connInfo != null && message.hasOwnProperty("connInfo"))\n                    object.connInfo = options.bytes === String ? $util.base64.encode(message.connInfo, 0, message.connInfo.length) : options.bytes === Array ? Array.prototype.slice.call(message.connInfo) : message.connInfo;\n                if (message.chanInfo != null && message.hasOwnProperty("chanInfo"))\n                    object.chanInfo = options.bytes === String ? $util.base64.encode(message.chanInfo, 0, message.chanInfo.length) : options.bytes === Array ? Array.prototype.slice.call(message.chanInfo) : message.chanInfo;\n                return object;\n            };\n    \n            /**\n             * Converts this ClientInfo to JSON.\n             * @function toJSON\n             * @memberof proto.ClientInfo\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ClientInfo.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return ClientInfo;\n        })();\n    \n        proto.Publication = (function() {\n    \n            /**\n             * Properties of a Publication.\n             * @memberof proto\n             * @interface IPublication\n             * @property {string|null} [uid] Publication uid\n             * @property {Uint8Array|null} [data] Publication data\n             * @property {proto.IClientInfo|null} [info] Publication info\n             */\n    \n            /**\n             * Constructs a new Publication.\n             * @memberof proto\n             * @classdesc Represents a Publication.\n             * @implements IPublication\n             * @constructor\n             * @param {proto.IPublication=} [properties] Properties to set\n             */\n            function Publication(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * Publication uid.\n             * @member {string} uid\n             * @memberof proto.Publication\n             * @instance\n             */\n            Publication.prototype.uid = "";\n    \n            /**\n             * Publication data.\n             * @member {Uint8Array} data\n             * @memberof proto.Publication\n             * @instance\n             */\n            Publication.prototype.data = $util.newBuffer([]);\n    \n            /**\n             * Publication info.\n             * @member {proto.IClientInfo|null|undefined} info\n             * @memberof proto.Publication\n             * @instance\n             */\n            Publication.prototype.info = null;\n    \n            /**\n             * Creates a new Publication instance using the specified properties.\n             * @function create\n             * @memberof proto.Publication\n             * @static\n             * @param {proto.IPublication=} [properties] Properties to set\n             * @returns {proto.Publication} Publication instance\n             */\n            Publication.create = function create(properties) {\n                return new Publication(properties);\n            };\n    \n            /**\n             * Encodes the specified Publication message. Does not implicitly {@link proto.Publication.verify|verify} messages.\n             * @function encode\n             * @memberof proto.Publication\n             * @static\n             * @param {proto.IPublication} message Publication message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Publication.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.uid != null && message.hasOwnProperty("uid"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);\n                if (message.data != null && message.hasOwnProperty("data"))\n                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);\n                if (message.info != null && message.hasOwnProperty("info"))\n                    $root.proto.ClientInfo.encode(message.info, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified Publication message, length delimited. Does not implicitly {@link proto.Publication.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.Publication\n             * @static\n             * @param {proto.IPublication} message Publication message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Publication.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a Publication message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.Publication\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.Publication} Publication\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Publication.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Publication();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.uid = reader.string();\n                        break;\n                    case 2:\n                        message.data = reader.bytes();\n                        break;\n                    case 3:\n                        message.info = $root.proto.ClientInfo.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a Publication message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.Publication\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.Publication} Publication\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Publication.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a Publication message.\n             * @function verify\n             * @memberof proto.Publication\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Publication.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.uid != null && message.hasOwnProperty("uid"))\n                    if (!$util.isString(message.uid))\n                        return "uid: string expected";\n                if (message.data != null && message.hasOwnProperty("data"))\n                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))\n                        return "data: buffer expected";\n                if (message.info != null && message.hasOwnProperty("info")) {\n                    var error = $root.proto.ClientInfo.verify(message.info);\n                    if (error)\n                        return "info." + error;\n                }\n                return null;\n            };\n    \n            /**\n             * Creates a Publication message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.Publication\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.Publication} Publication\n             */\n            Publication.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.Publication)\n                    return object;\n                var message = new $root.proto.Publication();\n                if (object.uid != null)\n                    message.uid = String(object.uid);\n                if (object.data != null)\n                    if (typeof object.data === "string")\n                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);\n                    else if (object.data.length)\n                        message.data = object.data;\n                if (object.info != null) {\n                    if (typeof object.info !== "object")\n                        throw TypeError(".proto.Publication.info: object expected");\n                    message.info = $root.proto.ClientInfo.fromObject(object.info);\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a Publication message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.Publication\n             * @static\n             * @param {proto.Publication} message Publication\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Publication.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.uid = "";\n                    object.data = options.bytes === String ? "" : [];\n                    object.info = null;\n                }\n                if (message.uid != null && message.hasOwnProperty("uid"))\n                    object.uid = message.uid;\n                if (message.data != null && message.hasOwnProperty("data"))\n                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;\n                if (message.info != null && message.hasOwnProperty("info"))\n                    object.info = $root.proto.ClientInfo.toObject(message.info, options);\n                return object;\n            };\n    \n            /**\n             * Converts this Publication to JSON.\n             * @function toJSON\n             * @memberof proto.Publication\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Publication.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return Publication;\n        })();\n    \n        proto.Join = (function() {\n    \n            /**\n             * Properties of a Join.\n             * @memberof proto\n             * @interface IJoin\n             * @property {proto.IClientInfo|null} [info] Join info\n             */\n    \n            /**\n             * Constructs a new Join.\n             * @memberof proto\n             * @classdesc Represents a Join.\n             * @implements IJoin\n             * @constructor\n             * @param {proto.IJoin=} [properties] Properties to set\n             */\n            function Join(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * Join info.\n             * @member {proto.IClientInfo|null|undefined} info\n             * @memberof proto.Join\n             * @instance\n             */\n            Join.prototype.info = null;\n    \n            /**\n             * Creates a new Join instance using the specified properties.\n             * @function create\n             * @memberof proto.Join\n             * @static\n             * @param {proto.IJoin=} [properties] Properties to set\n             * @returns {proto.Join} Join instance\n             */\n            Join.create = function create(properties) {\n                return new Join(properties);\n            };\n    \n            /**\n             * Encodes the specified Join message. Does not implicitly {@link proto.Join.verify|verify} messages.\n             * @function encode\n             * @memberof proto.Join\n             * @static\n             * @param {proto.IJoin} message Join message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Join.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.info != null && message.hasOwnProperty("info"))\n                    $root.proto.ClientInfo.encode(message.info, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified Join message, length delimited. Does not implicitly {@link proto.Join.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.Join\n             * @static\n             * @param {proto.IJoin} message Join message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Join.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a Join message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.Join\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.Join} Join\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Join.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Join();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.info = $root.proto.ClientInfo.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a Join message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.Join\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.Join} Join\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Join.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a Join message.\n             * @function verify\n             * @memberof proto.Join\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Join.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.info != null && message.hasOwnProperty("info")) {\n                    var error = $root.proto.ClientInfo.verify(message.info);\n                    if (error)\n                        return "info." + error;\n                }\n                return null;\n            };\n    \n            /**\n             * Creates a Join message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.Join\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.Join} Join\n             */\n            Join.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.Join)\n                    return object;\n                var message = new $root.proto.Join();\n                if (object.info != null) {\n                    if (typeof object.info !== "object")\n                        throw TypeError(".proto.Join.info: object expected");\n                    message.info = $root.proto.ClientInfo.fromObject(object.info);\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a Join message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.Join\n             * @static\n             * @param {proto.Join} message Join\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Join.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.info = null;\n                if (message.info != null && message.hasOwnProperty("info"))\n                    object.info = $root.proto.ClientInfo.toObject(message.info, options);\n                return object;\n            };\n    \n            /**\n             * Converts this Join to JSON.\n             * @function toJSON\n             * @memberof proto.Join\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Join.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return Join;\n        })();\n    \n        proto.Leave = (function() {\n    \n            /**\n             * Properties of a Leave.\n             * @memberof proto\n             * @interface ILeave\n             * @property {proto.IClientInfo|null} [info] Leave info\n             */\n    \n            /**\n             * Constructs a new Leave.\n             * @memberof proto\n             * @classdesc Represents a Leave.\n             * @implements ILeave\n             * @constructor\n             * @param {proto.ILeave=} [properties] Properties to set\n             */\n            function Leave(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * Leave info.\n             * @member {proto.IClientInfo|null|undefined} info\n             * @memberof proto.Leave\n             * @instance\n             */\n            Leave.prototype.info = null;\n    \n            /**\n             * Creates a new Leave instance using the specified properties.\n             * @function create\n             * @memberof proto.Leave\n             * @static\n             * @param {proto.ILeave=} [properties] Properties to set\n             * @returns {proto.Leave} Leave instance\n             */\n            Leave.create = function create(properties) {\n                return new Leave(properties);\n            };\n    \n            /**\n             * Encodes the specified Leave message. Does not implicitly {@link proto.Leave.verify|verify} messages.\n             * @function encode\n             * @memberof proto.Leave\n             * @static\n             * @param {proto.ILeave} message Leave message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Leave.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.info != null && message.hasOwnProperty("info"))\n                    $root.proto.ClientInfo.encode(message.info, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified Leave message, length delimited. Does not implicitly {@link proto.Leave.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.Leave\n             * @static\n             * @param {proto.ILeave} message Leave message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Leave.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a Leave message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.Leave\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.Leave} Leave\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Leave.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Leave();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.info = $root.proto.ClientInfo.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a Leave message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.Leave\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.Leave} Leave\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Leave.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a Leave message.\n             * @function verify\n             * @memberof proto.Leave\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Leave.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.info != null && message.hasOwnProperty("info")) {\n                    var error = $root.proto.ClientInfo.verify(message.info);\n                    if (error)\n                        return "info." + error;\n                }\n                return null;\n            };\n    \n            /**\n             * Creates a Leave message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.Leave\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.Leave} Leave\n             */\n            Leave.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.Leave)\n                    return object;\n                var message = new $root.proto.Leave();\n                if (object.info != null) {\n                    if (typeof object.info !== "object")\n                        throw TypeError(".proto.Leave.info: object expected");\n                    message.info = $root.proto.ClientInfo.fromObject(object.info);\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a Leave message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.Leave\n             * @static\n             * @param {proto.Leave} message Leave\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Leave.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.info = null;\n                if (message.info != null && message.hasOwnProperty("info"))\n                    object.info = $root.proto.ClientInfo.toObject(message.info, options);\n                return object;\n            };\n    \n            /**\n             * Converts this Leave to JSON.\n             * @function toJSON\n             * @memberof proto.Leave\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Leave.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return Leave;\n        })();\n    \n        proto.Unsub = (function() {\n    \n            /**\n             * Properties of an Unsub.\n             * @memberof proto\n             * @interface IUnsub\n             */\n    \n            /**\n             * Constructs a new Unsub.\n             * @memberof proto\n             * @classdesc Represents an Unsub.\n             * @implements IUnsub\n             * @constructor\n             * @param {proto.IUnsub=} [properties] Properties to set\n             */\n            function Unsub(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * Creates a new Unsub instance using the specified properties.\n             * @function create\n             * @memberof proto.Unsub\n             * @static\n             * @param {proto.IUnsub=} [properties] Properties to set\n             * @returns {proto.Unsub} Unsub instance\n             */\n            Unsub.create = function create(properties) {\n                return new Unsub(properties);\n            };\n    \n            /**\n             * Encodes the specified Unsub message. Does not implicitly {@link proto.Unsub.verify|verify} messages.\n             * @function encode\n             * @memberof proto.Unsub\n             * @static\n             * @param {proto.IUnsub} message Unsub message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Unsub.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified Unsub message, length delimited. Does not implicitly {@link proto.Unsub.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.Unsub\n             * @static\n             * @param {proto.IUnsub} message Unsub message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Unsub.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes an Unsub message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.Unsub\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.Unsub} Unsub\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Unsub.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Unsub();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes an Unsub message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.Unsub\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.Unsub} Unsub\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Unsub.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies an Unsub message.\n             * @function verify\n             * @memberof proto.Unsub\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Unsub.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                return null;\n            };\n    \n            /**\n             * Creates an Unsub message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.Unsub\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.Unsub} Unsub\n             */\n            Unsub.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.Unsub)\n                    return object;\n                return new $root.proto.Unsub();\n            };\n    \n            /**\n             * Creates a plain object from an Unsub message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.Unsub\n             * @static\n             * @param {proto.Unsub} message Unsub\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Unsub.toObject = function toObject() {\n                return {};\n            };\n    \n            /**\n             * Converts this Unsub to JSON.\n             * @function toJSON\n             * @memberof proto.Unsub\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Unsub.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return Unsub;\n        })();\n    \n        proto.ConnectRequest = (function() {\n    \n            /**\n             * Properties of a ConnectRequest.\n             * @memberof proto\n             * @interface IConnectRequest\n             * @property {string|null} [user] ConnectRequest user\n             * @property {string|null} [exp] ConnectRequest exp\n             * @property {string|null} [info] ConnectRequest info\n             * @property {string|null} [opts] ConnectRequest opts\n             * @property {string|null} [sign] ConnectRequest sign\n             */\n    \n            /**\n             * Constructs a new ConnectRequest.\n             * @memberof proto\n             * @classdesc Represents a ConnectRequest.\n             * @implements IConnectRequest\n             * @constructor\n             * @param {proto.IConnectRequest=} [properties] Properties to set\n             */\n            function ConnectRequest(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * ConnectRequest user.\n             * @member {string} user\n             * @memberof proto.ConnectRequest\n             * @instance\n             */\n            ConnectRequest.prototype.user = "";\n    \n            /**\n             * ConnectRequest exp.\n             * @member {string} exp\n             * @memberof proto.ConnectRequest\n             * @instance\n             */\n            ConnectRequest.prototype.exp = "";\n    \n            /**\n             * ConnectRequest info.\n             * @member {string} info\n             * @memberof proto.ConnectRequest\n             * @instance\n             */\n            ConnectRequest.prototype.info = "";\n    \n            /**\n             * ConnectRequest opts.\n             * @member {string} opts\n             * @memberof proto.ConnectRequest\n             * @instance\n             */\n            ConnectRequest.prototype.opts = "";\n    \n            /**\n             * ConnectRequest sign.\n             * @member {string} sign\n             * @memberof proto.ConnectRequest\n             * @instance\n             */\n            ConnectRequest.prototype.sign = "";\n    \n            /**\n             * Creates a new ConnectRequest instance using the specified properties.\n             * @function create\n             * @memberof proto.ConnectRequest\n             * @static\n             * @param {proto.IConnectRequest=} [properties] Properties to set\n             * @returns {proto.ConnectRequest} ConnectRequest instance\n             */\n            ConnectRequest.create = function create(properties) {\n                return new ConnectRequest(properties);\n            };\n    \n            /**\n             * Encodes the specified ConnectRequest message. Does not implicitly {@link proto.ConnectRequest.verify|verify} messages.\n             * @function encode\n             * @memberof proto.ConnectRequest\n             * @static\n             * @param {proto.IConnectRequest} message ConnectRequest message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ConnectRequest.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.user != null && message.hasOwnProperty("user"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.user);\n                if (message.exp != null && message.hasOwnProperty("exp"))\n                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.exp);\n                if (message.info != null && message.hasOwnProperty("info"))\n                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.info);\n                if (message.opts != null && message.hasOwnProperty("opts"))\n                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.opts);\n                if (message.sign != null && message.hasOwnProperty("sign"))\n                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.sign);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified ConnectRequest message, length delimited. Does not implicitly {@link proto.ConnectRequest.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.ConnectRequest\n             * @static\n             * @param {proto.IConnectRequest} message ConnectRequest message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ConnectRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a ConnectRequest message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.ConnectRequest\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.ConnectRequest} ConnectRequest\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ConnectRequest.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ConnectRequest();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.user = reader.string();\n                        break;\n                    case 2:\n                        message.exp = reader.string();\n                        break;\n                    case 3:\n                        message.info = reader.string();\n                        break;\n                    case 4:\n                        message.opts = reader.string();\n                        break;\n                    case 5:\n                        message.sign = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a ConnectRequest message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.ConnectRequest\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.ConnectRequest} ConnectRequest\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ConnectRequest.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a ConnectRequest message.\n             * @function verify\n             * @memberof proto.ConnectRequest\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            ConnectRequest.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.user != null && message.hasOwnProperty("user"))\n                    if (!$util.isString(message.user))\n                        return "user: string expected";\n                if (message.exp != null && message.hasOwnProperty("exp"))\n                    if (!$util.isString(message.exp))\n                        return "exp: string expected";\n                if (message.info != null && message.hasOwnProperty("info"))\n                    if (!$util.isString(message.info))\n                        return "info: string expected";\n                if (message.opts != null && message.hasOwnProperty("opts"))\n                    if (!$util.isString(message.opts))\n                        return "opts: string expected";\n                if (message.sign != null && message.hasOwnProperty("sign"))\n                    if (!$util.isString(message.sign))\n                        return "sign: string expected";\n                return null;\n            };\n    \n            /**\n             * Creates a ConnectRequest message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.ConnectRequest\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.ConnectRequest} ConnectRequest\n             */\n            ConnectRequest.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.ConnectRequest)\n                    return object;\n                var message = new $root.proto.ConnectRequest();\n                if (object.user != null)\n                    message.user = String(object.user);\n                if (object.exp != null)\n                    message.exp = String(object.exp);\n                if (object.info != null)\n                    message.info = String(object.info);\n                if (object.opts != null)\n                    message.opts = String(object.opts);\n                if (object.sign != null)\n                    message.sign = String(object.sign);\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a ConnectRequest message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.ConnectRequest\n             * @static\n             * @param {proto.ConnectRequest} message ConnectRequest\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ConnectRequest.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.user = "";\n                    object.exp = "";\n                    object.info = "";\n                    object.opts = "";\n                    object.sign = "";\n                }\n                if (message.user != null && message.hasOwnProperty("user"))\n                    object.user = message.user;\n                if (message.exp != null && message.hasOwnProperty("exp"))\n                    object.exp = message.exp;\n                if (message.info != null && message.hasOwnProperty("info"))\n                    object.info = message.info;\n                if (message.opts != null && message.hasOwnProperty("opts"))\n                    object.opts = message.opts;\n                if (message.sign != null && message.hasOwnProperty("sign"))\n                    object.sign = message.sign;\n                return object;\n            };\n    \n            /**\n             * Converts this ConnectRequest to JSON.\n             * @function toJSON\n             * @memberof proto.ConnectRequest\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ConnectRequest.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return ConnectRequest;\n        })();\n    \n        proto.ConnectResponse = (function() {\n    \n            /**\n             * Properties of a ConnectResponse.\n             * @memberof proto\n             * @interface IConnectResponse\n             * @property {proto.IError|null} [error] ConnectResponse error\n             * @property {proto.IConnectResult|null} [result] ConnectResponse result\n             */\n    \n            /**\n             * Constructs a new ConnectResponse.\n             * @memberof proto\n             * @classdesc Represents a ConnectResponse.\n             * @implements IConnectResponse\n             * @constructor\n             * @param {proto.IConnectResponse=} [properties] Properties to set\n             */\n            function ConnectResponse(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * ConnectResponse error.\n             * @member {proto.IError|null|undefined} error\n             * @memberof proto.ConnectResponse\n             * @instance\n             */\n            ConnectResponse.prototype.error = null;\n    \n            /**\n             * ConnectResponse result.\n             * @member {proto.IConnectResult|null|undefined} result\n             * @memberof proto.ConnectResponse\n             * @instance\n             */\n            ConnectResponse.prototype.result = null;\n    \n            /**\n             * Creates a new ConnectResponse instance using the specified properties.\n             * @function create\n             * @memberof proto.ConnectResponse\n             * @static\n             * @param {proto.IConnectResponse=} [properties] Properties to set\n             * @returns {proto.ConnectResponse} ConnectResponse instance\n             */\n            ConnectResponse.create = function create(properties) {\n                return new ConnectResponse(properties);\n            };\n    \n            /**\n             * Encodes the specified ConnectResponse message. Does not implicitly {@link proto.ConnectResponse.verify|verify} messages.\n             * @function encode\n             * @memberof proto.ConnectResponse\n             * @static\n             * @param {proto.IConnectResponse} message ConnectResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ConnectResponse.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.error != null && message.hasOwnProperty("error"))\n                    $root.proto.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                if (message.result != null && message.hasOwnProperty("result"))\n                    $root.proto.ConnectResult.encode(message.result, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified ConnectResponse message, length delimited. Does not implicitly {@link proto.ConnectResponse.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.ConnectResponse\n             * @static\n             * @param {proto.IConnectResponse} message ConnectResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ConnectResponse.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a ConnectResponse message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.ConnectResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.ConnectResponse} ConnectResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ConnectResponse.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ConnectResponse();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.error = $root.proto.Error.decode(reader, reader.uint32());\n                        break;\n                    case 2:\n                        message.result = $root.proto.ConnectResult.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a ConnectResponse message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.ConnectResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.ConnectResponse} ConnectResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ConnectResponse.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a ConnectResponse message.\n             * @function verify\n             * @memberof proto.ConnectResponse\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            ConnectResponse.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.error != null && message.hasOwnProperty("error")) {\n                    var error = $root.proto.Error.verify(message.error);\n                    if (error)\n                        return "error." + error;\n                }\n                if (message.result != null && message.hasOwnProperty("result")) {\n                    var error = $root.proto.ConnectResult.verify(message.result);\n                    if (error)\n                        return "result." + error;\n                }\n                return null;\n            };\n    \n            /**\n             * Creates a ConnectResponse message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.ConnectResponse\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.ConnectResponse} ConnectResponse\n             */\n            ConnectResponse.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.ConnectResponse)\n                    return object;\n                var message = new $root.proto.ConnectResponse();\n                if (object.error != null) {\n                    if (typeof object.error !== "object")\n                        throw TypeError(".proto.ConnectResponse.error: object expected");\n                    message.error = $root.proto.Error.fromObject(object.error);\n                }\n                if (object.result != null) {\n                    if (typeof object.result !== "object")\n                        throw TypeError(".proto.ConnectResponse.result: object expected");\n                    message.result = $root.proto.ConnectResult.fromObject(object.result);\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a ConnectResponse message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.ConnectResponse\n             * @static\n             * @param {proto.ConnectResponse} message ConnectResponse\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ConnectResponse.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.error = null;\n                    object.result = null;\n                }\n                if (message.error != null && message.hasOwnProperty("error"))\n                    object.error = $root.proto.Error.toObject(message.error, options);\n                if (message.result != null && message.hasOwnProperty("result"))\n                    object.result = $root.proto.ConnectResult.toObject(message.result, options);\n                return object;\n            };\n    \n            /**\n             * Converts this ConnectResponse to JSON.\n             * @function toJSON\n             * @memberof proto.ConnectResponse\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ConnectResponse.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return ConnectResponse;\n        })();\n    \n        proto.ConnectResult = (function() {\n    \n            /**\n             * Properties of a ConnectResult.\n             * @memberof proto\n             * @interface IConnectResult\n             * @property {string|null} [client] ConnectResult client\n             * @property {string|null} [version] ConnectResult version\n             * @property {boolean|null} [expires] ConnectResult expires\n             * @property {boolean|null} [expired] ConnectResult expired\n             * @property {number|null} [ttl] ConnectResult ttl\n             */\n    \n            /**\n             * Constructs a new ConnectResult.\n             * @memberof proto\n             * @classdesc Represents a ConnectResult.\n             * @implements IConnectResult\n             * @constructor\n             * @param {proto.IConnectResult=} [properties] Properties to set\n             */\n            function ConnectResult(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * ConnectResult client.\n             * @member {string} client\n             * @memberof proto.ConnectResult\n             * @instance\n             */\n            ConnectResult.prototype.client = "";\n    \n            /**\n             * ConnectResult version.\n             * @member {string} version\n             * @memberof proto.ConnectResult\n             * @instance\n             */\n            ConnectResult.prototype.version = "";\n    \n            /**\n             * ConnectResult expires.\n             * @member {boolean} expires\n             * @memberof proto.ConnectResult\n             * @instance\n             */\n            ConnectResult.prototype.expires = false;\n    \n            /**\n             * ConnectResult expired.\n             * @member {boolean} expired\n             * @memberof proto.ConnectResult\n             * @instance\n             */\n            ConnectResult.prototype.expired = false;\n    \n            /**\n             * ConnectResult ttl.\n             * @member {number} ttl\n             * @memberof proto.ConnectResult\n             * @instance\n             */\n            ConnectResult.prototype.ttl = 0;\n    \n            /**\n             * Creates a new ConnectResult instance using the specified properties.\n             * @function create\n             * @memberof proto.ConnectResult\n             * @static\n             * @param {proto.IConnectResult=} [properties] Properties to set\n             * @returns {proto.ConnectResult} ConnectResult instance\n             */\n            ConnectResult.create = function create(properties) {\n                return new ConnectResult(properties);\n            };\n    \n            /**\n             * Encodes the specified ConnectResult message. Does not implicitly {@link proto.ConnectResult.verify|verify} messages.\n             * @function encode\n             * @memberof proto.ConnectResult\n             * @static\n             * @param {proto.IConnectResult} message ConnectResult message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ConnectResult.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.client != null && message.hasOwnProperty("client"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.client);\n                if (message.version != null && message.hasOwnProperty("version"))\n                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);\n                if (message.expires != null && message.hasOwnProperty("expires"))\n                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.expires);\n                if (message.expired != null && message.hasOwnProperty("expired"))\n                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.expired);\n                if (message.ttl != null && message.hasOwnProperty("ttl"))\n                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.ttl);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified ConnectResult message, length delimited. Does not implicitly {@link proto.ConnectResult.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.ConnectResult\n             * @static\n             * @param {proto.IConnectResult} message ConnectResult message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ConnectResult.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a ConnectResult message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.ConnectResult\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.ConnectResult} ConnectResult\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ConnectResult.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ConnectResult();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.client = reader.string();\n                        break;\n                    case 2:\n                        message.version = reader.string();\n                        break;\n                    case 3:\n                        message.expires = reader.bool();\n                        break;\n                    case 4:\n                        message.expired = reader.bool();\n                        break;\n                    case 5:\n                        message.ttl = reader.uint32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a ConnectResult message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.ConnectResult\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.ConnectResult} ConnectResult\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ConnectResult.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a ConnectResult message.\n             * @function verify\n             * @memberof proto.ConnectResult\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            ConnectResult.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.client != null && message.hasOwnProperty("client"))\n                    if (!$util.isString(message.client))\n                        return "client: string expected";\n                if (message.version != null && message.hasOwnProperty("version"))\n                    if (!$util.isString(message.version))\n                        return "version: string expected";\n                if (message.expires != null && message.hasOwnProperty("expires"))\n                    if (typeof message.expires !== "boolean")\n                        return "expires: boolean expected";\n                if (message.expired != null && message.hasOwnProperty("expired"))\n                    if (typeof message.expired !== "boolean")\n                        return "expired: boolean expected";\n                if (message.ttl != null && message.hasOwnProperty("ttl"))\n                    if (!$util.isInteger(message.ttl))\n                        return "ttl: integer expected";\n                return null;\n            };\n    \n            /**\n             * Creates a ConnectResult message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.ConnectResult\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.ConnectResult} ConnectResult\n             */\n            ConnectResult.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.ConnectResult)\n                    return object;\n                var message = new $root.proto.ConnectResult();\n                if (object.client != null)\n                    message.client = String(object.client);\n                if (object.version != null)\n                    message.version = String(object.version);\n                if (object.expires != null)\n                    message.expires = Boolean(object.expires);\n                if (object.expired != null)\n                    message.expired = Boolean(object.expired);\n                if (object.ttl != null)\n                    message.ttl = object.ttl >>> 0;\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a ConnectResult message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.ConnectResult\n             * @static\n             * @param {proto.ConnectResult} message ConnectResult\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ConnectResult.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.client = "";\n                    object.version = "";\n                    object.expires = false;\n                    object.expired = false;\n                    object.ttl = 0;\n                }\n                if (message.client != null && message.hasOwnProperty("client"))\n                    object.client = message.client;\n                if (message.version != null && message.hasOwnProperty("version"))\n                    object.version = message.version;\n                if (message.expires != null && message.hasOwnProperty("expires"))\n                    object.expires = message.expires;\n                if (message.expired != null && message.hasOwnProperty("expired"))\n                    object.expired = message.expired;\n                if (message.ttl != null && message.hasOwnProperty("ttl"))\n                    object.ttl = message.ttl;\n                return object;\n            };\n    \n            /**\n             * Converts this ConnectResult to JSON.\n             * @function toJSON\n             * @memberof proto.ConnectResult\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ConnectResult.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return ConnectResult;\n        })();\n    \n        proto.RefreshRequest = (function() {\n    \n            /**\n             * Properties of a RefreshRequest.\n             * @memberof proto\n             * @interface IRefreshRequest\n             * @property {string|null} [user] RefreshRequest user\n             * @property {string|null} [exp] RefreshRequest exp\n             * @property {string|null} [info] RefreshRequest info\n             * @property {string|null} [opts] RefreshRequest opts\n             * @property {string|null} [sign] RefreshRequest sign\n             */\n    \n            /**\n             * Constructs a new RefreshRequest.\n             * @memberof proto\n             * @classdesc Represents a RefreshRequest.\n             * @implements IRefreshRequest\n             * @constructor\n             * @param {proto.IRefreshRequest=} [properties] Properties to set\n             */\n            function RefreshRequest(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * RefreshRequest user.\n             * @member {string} user\n             * @memberof proto.RefreshRequest\n             * @instance\n             */\n            RefreshRequest.prototype.user = "";\n    \n            /**\n             * RefreshRequest exp.\n             * @member {string} exp\n             * @memberof proto.RefreshRequest\n             * @instance\n             */\n            RefreshRequest.prototype.exp = "";\n    \n            /**\n             * RefreshRequest info.\n             * @member {string} info\n             * @memberof proto.RefreshRequest\n             * @instance\n             */\n            RefreshRequest.prototype.info = "";\n    \n            /**\n             * RefreshRequest opts.\n             * @member {string} opts\n             * @memberof proto.RefreshRequest\n             * @instance\n             */\n            RefreshRequest.prototype.opts = "";\n    \n            /**\n             * RefreshRequest sign.\n             * @member {string} sign\n             * @memberof proto.RefreshRequest\n             * @instance\n             */\n            RefreshRequest.prototype.sign = "";\n    \n            /**\n             * Creates a new RefreshRequest instance using the specified properties.\n             * @function create\n             * @memberof proto.RefreshRequest\n             * @static\n             * @param {proto.IRefreshRequest=} [properties] Properties to set\n             * @returns {proto.RefreshRequest} RefreshRequest instance\n             */\n            RefreshRequest.create = function create(properties) {\n                return new RefreshRequest(properties);\n            };\n    \n            /**\n             * Encodes the specified RefreshRequest message. Does not implicitly {@link proto.RefreshRequest.verify|verify} messages.\n             * @function encode\n             * @memberof proto.RefreshRequest\n             * @static\n             * @param {proto.IRefreshRequest} message RefreshRequest message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            RefreshRequest.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.user != null && message.hasOwnProperty("user"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.user);\n                if (message.exp != null && message.hasOwnProperty("exp"))\n                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.exp);\n                if (message.info != null && message.hasOwnProperty("info"))\n                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.info);\n                if (message.opts != null && message.hasOwnProperty("opts"))\n                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.opts);\n                if (message.sign != null && message.hasOwnProperty("sign"))\n                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.sign);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified RefreshRequest message, length delimited. Does not implicitly {@link proto.RefreshRequest.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.RefreshRequest\n             * @static\n             * @param {proto.IRefreshRequest} message RefreshRequest message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            RefreshRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a RefreshRequest message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.RefreshRequest\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.RefreshRequest} RefreshRequest\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            RefreshRequest.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RefreshRequest();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.user = reader.string();\n                        break;\n                    case 2:\n                        message.exp = reader.string();\n                        break;\n                    case 3:\n                        message.info = reader.string();\n                        break;\n                    case 4:\n                        message.opts = reader.string();\n                        break;\n                    case 5:\n                        message.sign = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a RefreshRequest message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.RefreshRequest\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.RefreshRequest} RefreshRequest\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            RefreshRequest.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a RefreshRequest message.\n             * @function verify\n             * @memberof proto.RefreshRequest\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            RefreshRequest.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.user != null && message.hasOwnProperty("user"))\n                    if (!$util.isString(message.user))\n                        return "user: string expected";\n                if (message.exp != null && message.hasOwnProperty("exp"))\n                    if (!$util.isString(message.exp))\n                        return "exp: string expected";\n                if (message.info != null && message.hasOwnProperty("info"))\n                    if (!$util.isString(message.info))\n                        return "info: string expected";\n                if (message.opts != null && message.hasOwnProperty("opts"))\n                    if (!$util.isString(message.opts))\n                        return "opts: string expected";\n                if (message.sign != null && message.hasOwnProperty("sign"))\n                    if (!$util.isString(message.sign))\n                        return "sign: string expected";\n                return null;\n            };\n    \n            /**\n             * Creates a RefreshRequest message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.RefreshRequest\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.RefreshRequest} RefreshRequest\n             */\n            RefreshRequest.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.RefreshRequest)\n                    return object;\n                var message = new $root.proto.RefreshRequest();\n                if (object.user != null)\n                    message.user = String(object.user);\n                if (object.exp != null)\n                    message.exp = String(object.exp);\n                if (object.info != null)\n                    message.info = String(object.info);\n                if (object.opts != null)\n                    message.opts = String(object.opts);\n                if (object.sign != null)\n                    message.sign = String(object.sign);\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a RefreshRequest message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.RefreshRequest\n             * @static\n             * @param {proto.RefreshRequest} message RefreshRequest\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            RefreshRequest.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.user = "";\n                    object.exp = "";\n                    object.info = "";\n                    object.opts = "";\n                    object.sign = "";\n                }\n                if (message.user != null && message.hasOwnProperty("user"))\n                    object.user = message.user;\n                if (message.exp != null && message.hasOwnProperty("exp"))\n                    object.exp = message.exp;\n                if (message.info != null && message.hasOwnProperty("info"))\n                    object.info = message.info;\n                if (message.opts != null && message.hasOwnProperty("opts"))\n                    object.opts = message.opts;\n                if (message.sign != null && message.hasOwnProperty("sign"))\n                    object.sign = message.sign;\n                return object;\n            };\n    \n            /**\n             * Converts this RefreshRequest to JSON.\n             * @function toJSON\n             * @memberof proto.RefreshRequest\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            RefreshRequest.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return RefreshRequest;\n        })();\n    \n        proto.RefreshResponse = (function() {\n    \n            /**\n             * Properties of a RefreshResponse.\n             * @memberof proto\n             * @interface IRefreshResponse\n             * @property {proto.IError|null} [error] RefreshResponse error\n             * @property {proto.IRefreshResult|null} [result] RefreshResponse result\n             */\n    \n            /**\n             * Constructs a new RefreshResponse.\n             * @memberof proto\n             * @classdesc Represents a RefreshResponse.\n             * @implements IRefreshResponse\n             * @constructor\n             * @param {proto.IRefreshResponse=} [properties] Properties to set\n             */\n            function RefreshResponse(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * RefreshResponse error.\n             * @member {proto.IError|null|undefined} error\n             * @memberof proto.RefreshResponse\n             * @instance\n             */\n            RefreshResponse.prototype.error = null;\n    \n            /**\n             * RefreshResponse result.\n             * @member {proto.IRefreshResult|null|undefined} result\n             * @memberof proto.RefreshResponse\n             * @instance\n             */\n            RefreshResponse.prototype.result = null;\n    \n            /**\n             * Creates a new RefreshResponse instance using the specified properties.\n             * @function create\n             * @memberof proto.RefreshResponse\n             * @static\n             * @param {proto.IRefreshResponse=} [properties] Properties to set\n             * @returns {proto.RefreshResponse} RefreshResponse instance\n             */\n            RefreshResponse.create = function create(properties) {\n                return new RefreshResponse(properties);\n            };\n    \n            /**\n             * Encodes the specified RefreshResponse message. Does not implicitly {@link proto.RefreshResponse.verify|verify} messages.\n             * @function encode\n             * @memberof proto.RefreshResponse\n             * @static\n             * @param {proto.IRefreshResponse} message RefreshResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            RefreshResponse.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.error != null && message.hasOwnProperty("error"))\n                    $root.proto.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                if (message.result != null && message.hasOwnProperty("result"))\n                    $root.proto.RefreshResult.encode(message.result, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified RefreshResponse message, length delimited. Does not implicitly {@link proto.RefreshResponse.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.RefreshResponse\n             * @static\n             * @param {proto.IRefreshResponse} message RefreshResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            RefreshResponse.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a RefreshResponse message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.RefreshResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.RefreshResponse} RefreshResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            RefreshResponse.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RefreshResponse();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.error = $root.proto.Error.decode(reader, reader.uint32());\n                        break;\n                    case 2:\n                        message.result = $root.proto.RefreshResult.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a RefreshResponse message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.RefreshResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.RefreshResponse} RefreshResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            RefreshResponse.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a RefreshResponse message.\n             * @function verify\n             * @memberof proto.RefreshResponse\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            RefreshResponse.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.error != null && message.hasOwnProperty("error")) {\n                    var error = $root.proto.Error.verify(message.error);\n                    if (error)\n                        return "error." + error;\n                }\n                if (message.result != null && message.hasOwnProperty("result")) {\n                    var error = $root.proto.RefreshResult.verify(message.result);\n                    if (error)\n                        return "result." + error;\n                }\n                return null;\n            };\n    \n            /**\n             * Creates a RefreshResponse message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.RefreshResponse\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.RefreshResponse} RefreshResponse\n             */\n            RefreshResponse.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.RefreshResponse)\n                    return object;\n                var message = new $root.proto.RefreshResponse();\n                if (object.error != null) {\n                    if (typeof object.error !== "object")\n                        throw TypeError(".proto.RefreshResponse.error: object expected");\n                    message.error = $root.proto.Error.fromObject(object.error);\n                }\n                if (object.result != null) {\n                    if (typeof object.result !== "object")\n                        throw TypeError(".proto.RefreshResponse.result: object expected");\n                    message.result = $root.proto.RefreshResult.fromObject(object.result);\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a RefreshResponse message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.RefreshResponse\n             * @static\n             * @param {proto.RefreshResponse} message RefreshResponse\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            RefreshResponse.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.error = null;\n                    object.result = null;\n                }\n                if (message.error != null && message.hasOwnProperty("error"))\n                    object.error = $root.proto.Error.toObject(message.error, options);\n                if (message.result != null && message.hasOwnProperty("result"))\n                    object.result = $root.proto.RefreshResult.toObject(message.result, options);\n                return object;\n            };\n    \n            /**\n             * Converts this RefreshResponse to JSON.\n             * @function toJSON\n             * @memberof proto.RefreshResponse\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            RefreshResponse.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return RefreshResponse;\n        })();\n    \n        proto.RefreshResult = (function() {\n    \n            /**\n             * Properties of a RefreshResult.\n             * @memberof proto\n             * @interface IRefreshResult\n             * @property {string|null} [client] RefreshResult client\n             * @property {string|null} [version] RefreshResult version\n             * @property {boolean|null} [expires] RefreshResult expires\n             * @property {boolean|null} [expired] RefreshResult expired\n             * @property {number|null} [ttl] RefreshResult ttl\n             */\n    \n            /**\n             * Constructs a new RefreshResult.\n             * @memberof proto\n             * @classdesc Represents a RefreshResult.\n             * @implements IRefreshResult\n             * @constructor\n             * @param {proto.IRefreshResult=} [properties] Properties to set\n             */\n            function RefreshResult(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * RefreshResult client.\n             * @member {string} client\n             * @memberof proto.RefreshResult\n             * @instance\n             */\n            RefreshResult.prototype.client = "";\n    \n            /**\n             * RefreshResult version.\n             * @member {string} version\n             * @memberof proto.RefreshResult\n             * @instance\n             */\n            RefreshResult.prototype.version = "";\n    \n            /**\n             * RefreshResult expires.\n             * @member {boolean} expires\n             * @memberof proto.RefreshResult\n             * @instance\n             */\n            RefreshResult.prototype.expires = false;\n    \n            /**\n             * RefreshResult expired.\n             * @member {boolean} expired\n             * @memberof proto.RefreshResult\n             * @instance\n             */\n            RefreshResult.prototype.expired = false;\n    \n            /**\n             * RefreshResult ttl.\n             * @member {number} ttl\n             * @memberof proto.RefreshResult\n             * @instance\n             */\n            RefreshResult.prototype.ttl = 0;\n    \n            /**\n             * Creates a new RefreshResult instance using the specified properties.\n             * @function create\n             * @memberof proto.RefreshResult\n             * @static\n             * @param {proto.IRefreshResult=} [properties] Properties to set\n             * @returns {proto.RefreshResult} RefreshResult instance\n             */\n            RefreshResult.create = function create(properties) {\n                return new RefreshResult(properties);\n            };\n    \n            /**\n             * Encodes the specified RefreshResult message. Does not implicitly {@link proto.RefreshResult.verify|verify} messages.\n             * @function encode\n             * @memberof proto.RefreshResult\n             * @static\n             * @param {proto.IRefreshResult} message RefreshResult message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            RefreshResult.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.client != null && message.hasOwnProperty("client"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.client);\n                if (message.version != null && message.hasOwnProperty("version"))\n                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);\n                if (message.expires != null && message.hasOwnProperty("expires"))\n                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.expires);\n                if (message.expired != null && message.hasOwnProperty("expired"))\n                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.expired);\n                if (message.ttl != null && message.hasOwnProperty("ttl"))\n                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.ttl);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified RefreshResult message, length delimited. Does not implicitly {@link proto.RefreshResult.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.RefreshResult\n             * @static\n             * @param {proto.IRefreshResult} message RefreshResult message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            RefreshResult.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a RefreshResult message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.RefreshResult\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.RefreshResult} RefreshResult\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            RefreshResult.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RefreshResult();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.client = reader.string();\n                        break;\n                    case 2:\n                        message.version = reader.string();\n                        break;\n                    case 3:\n                        message.expires = reader.bool();\n                        break;\n                    case 4:\n                        message.expired = reader.bool();\n                        break;\n                    case 5:\n                        message.ttl = reader.uint32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a RefreshResult message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.RefreshResult\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.RefreshResult} RefreshResult\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            RefreshResult.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a RefreshResult message.\n             * @function verify\n             * @memberof proto.RefreshResult\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            RefreshResult.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.client != null && message.hasOwnProperty("client"))\n                    if (!$util.isString(message.client))\n                        return "client: string expected";\n                if (message.version != null && message.hasOwnProperty("version"))\n                    if (!$util.isString(message.version))\n                        return "version: string expected";\n                if (message.expires != null && message.hasOwnProperty("expires"))\n                    if (typeof message.expires !== "boolean")\n                        return "expires: boolean expected";\n                if (message.expired != null && message.hasOwnProperty("expired"))\n                    if (typeof message.expired !== "boolean")\n                        return "expired: boolean expected";\n                if (message.ttl != null && message.hasOwnProperty("ttl"))\n                    if (!$util.isInteger(message.ttl))\n                        return "ttl: integer expected";\n                return null;\n            };\n    \n            /**\n             * Creates a RefreshResult message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.RefreshResult\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.RefreshResult} RefreshResult\n             */\n            RefreshResult.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.RefreshResult)\n                    return object;\n                var message = new $root.proto.RefreshResult();\n                if (object.client != null)\n                    message.client = String(object.client);\n                if (object.version != null)\n                    message.version = String(object.version);\n                if (object.expires != null)\n                    message.expires = Boolean(object.expires);\n                if (object.expired != null)\n                    message.expired = Boolean(object.expired);\n                if (object.ttl != null)\n                    message.ttl = object.ttl >>> 0;\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a RefreshResult message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.RefreshResult\n             * @static\n             * @param {proto.RefreshResult} message RefreshResult\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            RefreshResult.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.client = "";\n                    object.version = "";\n                    object.expires = false;\n                    object.expired = false;\n                    object.ttl = 0;\n                }\n                if (message.client != null && message.hasOwnProperty("client"))\n                    object.client = message.client;\n                if (message.version != null && message.hasOwnProperty("version"))\n                    object.version = message.version;\n                if (message.expires != null && message.hasOwnProperty("expires"))\n                    object.expires = message.expires;\n                if (message.expired != null && message.hasOwnProperty("expired"))\n                    object.expired = message.expired;\n                if (message.ttl != null && message.hasOwnProperty("ttl"))\n                    object.ttl = message.ttl;\n                return object;\n            };\n    \n            /**\n             * Converts this RefreshResult to JSON.\n             * @function toJSON\n             * @memberof proto.RefreshResult\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            RefreshResult.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return RefreshResult;\n        })();\n    \n        proto.SubscribeRequest = (function() {\n    \n            /**\n             * Properties of a SubscribeRequest.\n             * @memberof proto\n             * @interface ISubscribeRequest\n             * @property {string|null} [channel] SubscribeRequest channel\n             * @property {string|null} [client] SubscribeRequest client\n             * @property {string|null} [info] SubscribeRequest info\n             * @property {string|null} [sign] SubscribeRequest sign\n             * @property {boolean|null} [recover] SubscribeRequest recover\n             * @property {string|null} [last] SubscribeRequest last\n             */\n    \n            /**\n             * Constructs a new SubscribeRequest.\n             * @memberof proto\n             * @classdesc Represents a SubscribeRequest.\n             * @implements ISubscribeRequest\n             * @constructor\n             * @param {proto.ISubscribeRequest=} [properties] Properties to set\n             */\n            function SubscribeRequest(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * SubscribeRequest channel.\n             * @member {string} channel\n             * @memberof proto.SubscribeRequest\n             * @instance\n             */\n            SubscribeRequest.prototype.channel = "";\n    \n            /**\n             * SubscribeRequest client.\n             * @member {string} client\n             * @memberof proto.SubscribeRequest\n             * @instance\n             */\n            SubscribeRequest.prototype.client = "";\n    \n            /**\n             * SubscribeRequest info.\n             * @member {string} info\n             * @memberof proto.SubscribeRequest\n             * @instance\n             */\n            SubscribeRequest.prototype.info = "";\n    \n            /**\n             * SubscribeRequest sign.\n             * @member {string} sign\n             * @memberof proto.SubscribeRequest\n             * @instance\n             */\n            SubscribeRequest.prototype.sign = "";\n    \n            /**\n             * SubscribeRequest recover.\n             * @member {boolean} recover\n             * @memberof proto.SubscribeRequest\n             * @instance\n             */\n            SubscribeRequest.prototype.recover = false;\n    \n            /**\n             * SubscribeRequest last.\n             * @member {string} last\n             * @memberof proto.SubscribeRequest\n             * @instance\n             */\n            SubscribeRequest.prototype.last = "";\n    \n            /**\n             * Creates a new SubscribeRequest instance using the specified properties.\n             * @function create\n             * @memberof proto.SubscribeRequest\n             * @static\n             * @param {proto.ISubscribeRequest=} [properties] Properties to set\n             * @returns {proto.SubscribeRequest} SubscribeRequest instance\n             */\n            SubscribeRequest.create = function create(properties) {\n                return new SubscribeRequest(properties);\n            };\n    \n            /**\n             * Encodes the specified SubscribeRequest message. Does not implicitly {@link proto.SubscribeRequest.verify|verify} messages.\n             * @function encode\n             * @memberof proto.SubscribeRequest\n             * @static\n             * @param {proto.ISubscribeRequest} message SubscribeRequest message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SubscribeRequest.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);\n                if (message.client != null && message.hasOwnProperty("client"))\n                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.client);\n                if (message.info != null && message.hasOwnProperty("info"))\n                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.info);\n                if (message.sign != null && message.hasOwnProperty("sign"))\n                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.sign);\n                if (message.recover != null && message.hasOwnProperty("recover"))\n                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.recover);\n                if (message.last != null && message.hasOwnProperty("last"))\n                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.last);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified SubscribeRequest message, length delimited. Does not implicitly {@link proto.SubscribeRequest.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.SubscribeRequest\n             * @static\n             * @param {proto.ISubscribeRequest} message SubscribeRequest message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SubscribeRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a SubscribeRequest message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.SubscribeRequest\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.SubscribeRequest} SubscribeRequest\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SubscribeRequest.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SubscribeRequest();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.channel = reader.string();\n                        break;\n                    case 2:\n                        message.client = reader.string();\n                        break;\n                    case 3:\n                        message.info = reader.string();\n                        break;\n                    case 4:\n                        message.sign = reader.string();\n                        break;\n                    case 5:\n                        message.recover = reader.bool();\n                        break;\n                    case 6:\n                        message.last = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a SubscribeRequest message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.SubscribeRequest\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.SubscribeRequest} SubscribeRequest\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SubscribeRequest.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a SubscribeRequest message.\n             * @function verify\n             * @memberof proto.SubscribeRequest\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            SubscribeRequest.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    if (!$util.isString(message.channel))\n                        return "channel: string expected";\n                if (message.client != null && message.hasOwnProperty("client"))\n                    if (!$util.isString(message.client))\n                        return "client: string expected";\n                if (message.info != null && message.hasOwnProperty("info"))\n                    if (!$util.isString(message.info))\n                        return "info: string expected";\n                if (message.sign != null && message.hasOwnProperty("sign"))\n                    if (!$util.isString(message.sign))\n                        return "sign: string expected";\n                if (message.recover != null && message.hasOwnProperty("recover"))\n                    if (typeof message.recover !== "boolean")\n                        return "recover: boolean expected";\n                if (message.last != null && message.hasOwnProperty("last"))\n                    if (!$util.isString(message.last))\n                        return "last: string expected";\n                return null;\n            };\n    \n            /**\n             * Creates a SubscribeRequest message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.SubscribeRequest\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.SubscribeRequest} SubscribeRequest\n             */\n            SubscribeRequest.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.SubscribeRequest)\n                    return object;\n                var message = new $root.proto.SubscribeRequest();\n                if (object.channel != null)\n                    message.channel = String(object.channel);\n                if (object.client != null)\n                    message.client = String(object.client);\n                if (object.info != null)\n                    message.info = String(object.info);\n                if (object.sign != null)\n                    message.sign = String(object.sign);\n                if (object.recover != null)\n                    message.recover = Boolean(object.recover);\n                if (object.last != null)\n                    message.last = String(object.last);\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a SubscribeRequest message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.SubscribeRequest\n             * @static\n             * @param {proto.SubscribeRequest} message SubscribeRequest\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            SubscribeRequest.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.channel = "";\n                    object.client = "";\n                    object.info = "";\n                    object.sign = "";\n                    object.recover = false;\n                    object.last = "";\n                }\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    object.channel = message.channel;\n                if (message.client != null && message.hasOwnProperty("client"))\n                    object.client = message.client;\n                if (message.info != null && message.hasOwnProperty("info"))\n                    object.info = message.info;\n                if (message.sign != null && message.hasOwnProperty("sign"))\n                    object.sign = message.sign;\n                if (message.recover != null && message.hasOwnProperty("recover"))\n                    object.recover = message.recover;\n                if (message.last != null && message.hasOwnProperty("last"))\n                    object.last = message.last;\n                return object;\n            };\n    \n            /**\n             * Converts this SubscribeRequest to JSON.\n             * @function toJSON\n             * @memberof proto.SubscribeRequest\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            SubscribeRequest.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return SubscribeRequest;\n        })();\n    \n        proto.SubscribeResponse = (function() {\n    \n            /**\n             * Properties of a SubscribeResponse.\n             * @memberof proto\n             * @interface ISubscribeResponse\n             * @property {proto.IError|null} [error] SubscribeResponse error\n             * @property {proto.ISubscribeResult|null} [result] SubscribeResponse result\n             */\n    \n            /**\n             * Constructs a new SubscribeResponse.\n             * @memberof proto\n             * @classdesc Represents a SubscribeResponse.\n             * @implements ISubscribeResponse\n             * @constructor\n             * @param {proto.ISubscribeResponse=} [properties] Properties to set\n             */\n            function SubscribeResponse(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * SubscribeResponse error.\n             * @member {proto.IError|null|undefined} error\n             * @memberof proto.SubscribeResponse\n             * @instance\n             */\n            SubscribeResponse.prototype.error = null;\n    \n            /**\n             * SubscribeResponse result.\n             * @member {proto.ISubscribeResult|null|undefined} result\n             * @memberof proto.SubscribeResponse\n             * @instance\n             */\n            SubscribeResponse.prototype.result = null;\n    \n            /**\n             * Creates a new SubscribeResponse instance using the specified properties.\n             * @function create\n             * @memberof proto.SubscribeResponse\n             * @static\n             * @param {proto.ISubscribeResponse=} [properties] Properties to set\n             * @returns {proto.SubscribeResponse} SubscribeResponse instance\n             */\n            SubscribeResponse.create = function create(properties) {\n                return new SubscribeResponse(properties);\n            };\n    \n            /**\n             * Encodes the specified SubscribeResponse message. Does not implicitly {@link proto.SubscribeResponse.verify|verify} messages.\n             * @function encode\n             * @memberof proto.SubscribeResponse\n             * @static\n             * @param {proto.ISubscribeResponse} message SubscribeResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SubscribeResponse.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.error != null && message.hasOwnProperty("error"))\n                    $root.proto.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                if (message.result != null && message.hasOwnProperty("result"))\n                    $root.proto.SubscribeResult.encode(message.result, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified SubscribeResponse message, length delimited. Does not implicitly {@link proto.SubscribeResponse.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.SubscribeResponse\n             * @static\n             * @param {proto.ISubscribeResponse} message SubscribeResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SubscribeResponse.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a SubscribeResponse message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.SubscribeResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.SubscribeResponse} SubscribeResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SubscribeResponse.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SubscribeResponse();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.error = $root.proto.Error.decode(reader, reader.uint32());\n                        break;\n                    case 2:\n                        message.result = $root.proto.SubscribeResult.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a SubscribeResponse message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.SubscribeResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.SubscribeResponse} SubscribeResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SubscribeResponse.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a SubscribeResponse message.\n             * @function verify\n             * @memberof proto.SubscribeResponse\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            SubscribeResponse.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.error != null && message.hasOwnProperty("error")) {\n                    var error = $root.proto.Error.verify(message.error);\n                    if (error)\n                        return "error." + error;\n                }\n                if (message.result != null && message.hasOwnProperty("result")) {\n                    var error = $root.proto.SubscribeResult.verify(message.result);\n                    if (error)\n                        return "result." + error;\n                }\n                return null;\n            };\n    \n            /**\n             * Creates a SubscribeResponse message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.SubscribeResponse\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.SubscribeResponse} SubscribeResponse\n             */\n            SubscribeResponse.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.SubscribeResponse)\n                    return object;\n                var message = new $root.proto.SubscribeResponse();\n                if (object.error != null) {\n                    if (typeof object.error !== "object")\n                        throw TypeError(".proto.SubscribeResponse.error: object expected");\n                    message.error = $root.proto.Error.fromObject(object.error);\n                }\n                if (object.result != null) {\n                    if (typeof object.result !== "object")\n                        throw TypeError(".proto.SubscribeResponse.result: object expected");\n                    message.result = $root.proto.SubscribeResult.fromObject(object.result);\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a SubscribeResponse message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.SubscribeResponse\n             * @static\n             * @param {proto.SubscribeResponse} message SubscribeResponse\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            SubscribeResponse.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.error = null;\n                    object.result = null;\n                }\n                if (message.error != null && message.hasOwnProperty("error"))\n                    object.error = $root.proto.Error.toObject(message.error, options);\n                if (message.result != null && message.hasOwnProperty("result"))\n                    object.result = $root.proto.SubscribeResult.toObject(message.result, options);\n                return object;\n            };\n    \n            /**\n             * Converts this SubscribeResponse to JSON.\n             * @function toJSON\n             * @memberof proto.SubscribeResponse\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            SubscribeResponse.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return SubscribeResponse;\n        })();\n    \n        proto.SubscribeResult = (function() {\n    \n            /**\n             * Properties of a SubscribeResult.\n             * @memberof proto\n             * @interface ISubscribeResult\n             * @property {string|null} [last] SubscribeResult last\n             * @property {boolean|null} [recovered] SubscribeResult recovered\n             * @property {Array.<proto.IPublication>|null} [publications] SubscribeResult publications\n             */\n    \n            /**\n             * Constructs a new SubscribeResult.\n             * @memberof proto\n             * @classdesc Represents a SubscribeResult.\n             * @implements ISubscribeResult\n             * @constructor\n             * @param {proto.ISubscribeResult=} [properties] Properties to set\n             */\n            function SubscribeResult(properties) {\n                this.publications = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * SubscribeResult last.\n             * @member {string} last\n             * @memberof proto.SubscribeResult\n             * @instance\n             */\n            SubscribeResult.prototype.last = "";\n    \n            /**\n             * SubscribeResult recovered.\n             * @member {boolean} recovered\n             * @memberof proto.SubscribeResult\n             * @instance\n             */\n            SubscribeResult.prototype.recovered = false;\n    \n            /**\n             * SubscribeResult publications.\n             * @member {Array.<proto.IPublication>} publications\n             * @memberof proto.SubscribeResult\n             * @instance\n             */\n            SubscribeResult.prototype.publications = $util.emptyArray;\n    \n            /**\n             * Creates a new SubscribeResult instance using the specified properties.\n             * @function create\n             * @memberof proto.SubscribeResult\n             * @static\n             * @param {proto.ISubscribeResult=} [properties] Properties to set\n             * @returns {proto.SubscribeResult} SubscribeResult instance\n             */\n            SubscribeResult.create = function create(properties) {\n                return new SubscribeResult(properties);\n            };\n    \n            /**\n             * Encodes the specified SubscribeResult message. Does not implicitly {@link proto.SubscribeResult.verify|verify} messages.\n             * @function encode\n             * @memberof proto.SubscribeResult\n             * @static\n             * @param {proto.ISubscribeResult} message SubscribeResult message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SubscribeResult.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.last != null && message.hasOwnProperty("last"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.last);\n                if (message.recovered != null && message.hasOwnProperty("recovered"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.recovered);\n                if (message.publications != null && message.publications.length)\n                    for (var i = 0; i < message.publications.length; ++i)\n                        $root.proto.Publication.encode(message.publications[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified SubscribeResult message, length delimited. Does not implicitly {@link proto.SubscribeResult.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.SubscribeResult\n             * @static\n             * @param {proto.ISubscribeResult} message SubscribeResult message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SubscribeResult.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a SubscribeResult message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.SubscribeResult\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.SubscribeResult} SubscribeResult\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SubscribeResult.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SubscribeResult();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.last = reader.string();\n                        break;\n                    case 2:\n                        message.recovered = reader.bool();\n                        break;\n                    case 3:\n                        if (!(message.publications && message.publications.length))\n                            message.publications = [];\n                        message.publications.push($root.proto.Publication.decode(reader, reader.uint32()));\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a SubscribeResult message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.SubscribeResult\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.SubscribeResult} SubscribeResult\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SubscribeResult.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a SubscribeResult message.\n             * @function verify\n             * @memberof proto.SubscribeResult\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            SubscribeResult.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.last != null && message.hasOwnProperty("last"))\n                    if (!$util.isString(message.last))\n                        return "last: string expected";\n                if (message.recovered != null && message.hasOwnProperty("recovered"))\n                    if (typeof message.recovered !== "boolean")\n                        return "recovered: boolean expected";\n                if (message.publications != null && message.hasOwnProperty("publications")) {\n                    if (!Array.isArray(message.publications))\n                        return "publications: array expected";\n                    for (var i = 0; i < message.publications.length; ++i) {\n                        var error = $root.proto.Publication.verify(message.publications[i]);\n                        if (error)\n                            return "publications." + error;\n                    }\n                }\n                return null;\n            };\n    \n            /**\n             * Creates a SubscribeResult message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.SubscribeResult\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.SubscribeResult} SubscribeResult\n             */\n            SubscribeResult.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.SubscribeResult)\n                    return object;\n                var message = new $root.proto.SubscribeResult();\n                if (object.last != null)\n                    message.last = String(object.last);\n                if (object.recovered != null)\n                    message.recovered = Boolean(object.recovered);\n                if (object.publications) {\n                    if (!Array.isArray(object.publications))\n                        throw TypeError(".proto.SubscribeResult.publications: array expected");\n                    message.publications = [];\n                    for (var i = 0; i < object.publications.length; ++i) {\n                        if (typeof object.publications[i] !== "object")\n                            throw TypeError(".proto.SubscribeResult.publications: object expected");\n                        message.publications[i] = $root.proto.Publication.fromObject(object.publications[i]);\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a SubscribeResult message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.SubscribeResult\n             * @static\n             * @param {proto.SubscribeResult} message SubscribeResult\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            SubscribeResult.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.arrays || options.defaults)\n                    object.publications = [];\n                if (options.defaults) {\n                    object.last = "";\n                    object.recovered = false;\n                }\n                if (message.last != null && message.hasOwnProperty("last"))\n                    object.last = message.last;\n                if (message.recovered != null && message.hasOwnProperty("recovered"))\n                    object.recovered = message.recovered;\n                if (message.publications && message.publications.length) {\n                    object.publications = [];\n                    for (var j = 0; j < message.publications.length; ++j)\n                        object.publications[j] = $root.proto.Publication.toObject(message.publications[j], options);\n                }\n                return object;\n            };\n    \n            /**\n             * Converts this SubscribeResult to JSON.\n             * @function toJSON\n             * @memberof proto.SubscribeResult\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            SubscribeResult.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return SubscribeResult;\n        })();\n    \n        proto.UnsubscribeRequest = (function() {\n    \n            /**\n             * Properties of an UnsubscribeRequest.\n             * @memberof proto\n             * @interface IUnsubscribeRequest\n             * @property {string|null} [channel] UnsubscribeRequest channel\n             */\n    \n            /**\n             * Constructs a new UnsubscribeRequest.\n             * @memberof proto\n             * @classdesc Represents an UnsubscribeRequest.\n             * @implements IUnsubscribeRequest\n             * @constructor\n             * @param {proto.IUnsubscribeRequest=} [properties] Properties to set\n             */\n            function UnsubscribeRequest(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * UnsubscribeRequest channel.\n             * @member {string} channel\n             * @memberof proto.UnsubscribeRequest\n             * @instance\n             */\n            UnsubscribeRequest.prototype.channel = "";\n    \n            /**\n             * Creates a new UnsubscribeRequest instance using the specified properties.\n             * @function create\n             * @memberof proto.UnsubscribeRequest\n             * @static\n             * @param {proto.IUnsubscribeRequest=} [properties] Properties to set\n             * @returns {proto.UnsubscribeRequest} UnsubscribeRequest instance\n             */\n            UnsubscribeRequest.create = function create(properties) {\n                return new UnsubscribeRequest(properties);\n            };\n    \n            /**\n             * Encodes the specified UnsubscribeRequest message. Does not implicitly {@link proto.UnsubscribeRequest.verify|verify} messages.\n             * @function encode\n             * @memberof proto.UnsubscribeRequest\n             * @static\n             * @param {proto.IUnsubscribeRequest} message UnsubscribeRequest message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            UnsubscribeRequest.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified UnsubscribeRequest message, length delimited. Does not implicitly {@link proto.UnsubscribeRequest.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.UnsubscribeRequest\n             * @static\n             * @param {proto.IUnsubscribeRequest} message UnsubscribeRequest message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            UnsubscribeRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes an UnsubscribeRequest message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.UnsubscribeRequest\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.UnsubscribeRequest} UnsubscribeRequest\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            UnsubscribeRequest.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UnsubscribeRequest();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.channel = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes an UnsubscribeRequest message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.UnsubscribeRequest\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.UnsubscribeRequest} UnsubscribeRequest\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            UnsubscribeRequest.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies an UnsubscribeRequest message.\n             * @function verify\n             * @memberof proto.UnsubscribeRequest\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            UnsubscribeRequest.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    if (!$util.isString(message.channel))\n                        return "channel: string expected";\n                return null;\n            };\n    \n            /**\n             * Creates an UnsubscribeRequest message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.UnsubscribeRequest\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.UnsubscribeRequest} UnsubscribeRequest\n             */\n            UnsubscribeRequest.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.UnsubscribeRequest)\n                    return object;\n                var message = new $root.proto.UnsubscribeRequest();\n                if (object.channel != null)\n                    message.channel = String(object.channel);\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from an UnsubscribeRequest message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.UnsubscribeRequest\n             * @static\n             * @param {proto.UnsubscribeRequest} message UnsubscribeRequest\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            UnsubscribeRequest.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.channel = "";\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    object.channel = message.channel;\n                return object;\n            };\n    \n            /**\n             * Converts this UnsubscribeRequest to JSON.\n             * @function toJSON\n             * @memberof proto.UnsubscribeRequest\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            UnsubscribeRequest.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return UnsubscribeRequest;\n        })();\n    \n        proto.UnsubscribeResponse = (function() {\n    \n            /**\n             * Properties of an UnsubscribeResponse.\n             * @memberof proto\n             * @interface IUnsubscribeResponse\n             * @property {proto.IError|null} [error] UnsubscribeResponse error\n             * @property {proto.IUnsubscribeResult|null} [result] UnsubscribeResponse result\n             */\n    \n            /**\n             * Constructs a new UnsubscribeResponse.\n             * @memberof proto\n             * @classdesc Represents an UnsubscribeResponse.\n             * @implements IUnsubscribeResponse\n             * @constructor\n             * @param {proto.IUnsubscribeResponse=} [properties] Properties to set\n             */\n            function UnsubscribeResponse(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * UnsubscribeResponse error.\n             * @member {proto.IError|null|undefined} error\n             * @memberof proto.UnsubscribeResponse\n             * @instance\n             */\n            UnsubscribeResponse.prototype.error = null;\n    \n            /**\n             * UnsubscribeResponse result.\n             * @member {proto.IUnsubscribeResult|null|undefined} result\n             * @memberof proto.UnsubscribeResponse\n             * @instance\n             */\n            UnsubscribeResponse.prototype.result = null;\n    \n            /**\n             * Creates a new UnsubscribeResponse instance using the specified properties.\n             * @function create\n             * @memberof proto.UnsubscribeResponse\n             * @static\n             * @param {proto.IUnsubscribeResponse=} [properties] Properties to set\n             * @returns {proto.UnsubscribeResponse} UnsubscribeResponse instance\n             */\n            UnsubscribeResponse.create = function create(properties) {\n                return new UnsubscribeResponse(properties);\n            };\n    \n            /**\n             * Encodes the specified UnsubscribeResponse message. Does not implicitly {@link proto.UnsubscribeResponse.verify|verify} messages.\n             * @function encode\n             * @memberof proto.UnsubscribeResponse\n             * @static\n             * @param {proto.IUnsubscribeResponse} message UnsubscribeResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            UnsubscribeResponse.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.error != null && message.hasOwnProperty("error"))\n                    $root.proto.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                if (message.result != null && message.hasOwnProperty("result"))\n                    $root.proto.UnsubscribeResult.encode(message.result, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified UnsubscribeResponse message, length delimited. Does not implicitly {@link proto.UnsubscribeResponse.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.UnsubscribeResponse\n             * @static\n             * @param {proto.IUnsubscribeResponse} message UnsubscribeResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            UnsubscribeResponse.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes an UnsubscribeResponse message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.UnsubscribeResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.UnsubscribeResponse} UnsubscribeResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            UnsubscribeResponse.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UnsubscribeResponse();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.error = $root.proto.Error.decode(reader, reader.uint32());\n                        break;\n                    case 2:\n                        message.result = $root.proto.UnsubscribeResult.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes an UnsubscribeResponse message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.UnsubscribeResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.UnsubscribeResponse} UnsubscribeResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            UnsubscribeResponse.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies an UnsubscribeResponse message.\n             * @function verify\n             * @memberof proto.UnsubscribeResponse\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            UnsubscribeResponse.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.error != null && message.hasOwnProperty("error")) {\n                    var error = $root.proto.Error.verify(message.error);\n                    if (error)\n                        return "error." + error;\n                }\n                if (message.result != null && message.hasOwnProperty("result")) {\n                    var error = $root.proto.UnsubscribeResult.verify(message.result);\n                    if (error)\n                        return "result." + error;\n                }\n                return null;\n            };\n    \n            /**\n             * Creates an UnsubscribeResponse message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.UnsubscribeResponse\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.UnsubscribeResponse} UnsubscribeResponse\n             */\n            UnsubscribeResponse.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.UnsubscribeResponse)\n                    return object;\n                var message = new $root.proto.UnsubscribeResponse();\n                if (object.error != null) {\n                    if (typeof object.error !== "object")\n                        throw TypeError(".proto.UnsubscribeResponse.error: object expected");\n                    message.error = $root.proto.Error.fromObject(object.error);\n                }\n                if (object.result != null) {\n                    if (typeof object.result !== "object")\n                        throw TypeError(".proto.UnsubscribeResponse.result: object expected");\n                    message.result = $root.proto.UnsubscribeResult.fromObject(object.result);\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from an UnsubscribeResponse message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.UnsubscribeResponse\n             * @static\n             * @param {proto.UnsubscribeResponse} message UnsubscribeResponse\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            UnsubscribeResponse.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.error = null;\n                    object.result = null;\n                }\n                if (message.error != null && message.hasOwnProperty("error"))\n                    object.error = $root.proto.Error.toObject(message.error, options);\n                if (message.result != null && message.hasOwnProperty("result"))\n                    object.result = $root.proto.UnsubscribeResult.toObject(message.result, options);\n                return object;\n            };\n    \n            /**\n             * Converts this UnsubscribeResponse to JSON.\n             * @function toJSON\n             * @memberof proto.UnsubscribeResponse\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            UnsubscribeResponse.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return UnsubscribeResponse;\n        })();\n    \n        proto.UnsubscribeResult = (function() {\n    \n            /**\n             * Properties of an UnsubscribeResult.\n             * @memberof proto\n             * @interface IUnsubscribeResult\n             */\n    \n            /**\n             * Constructs a new UnsubscribeResult.\n             * @memberof proto\n             * @classdesc Represents an UnsubscribeResult.\n             * @implements IUnsubscribeResult\n             * @constructor\n             * @param {proto.IUnsubscribeResult=} [properties] Properties to set\n             */\n            function UnsubscribeResult(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * Creates a new UnsubscribeResult instance using the specified properties.\n             * @function create\n             * @memberof proto.UnsubscribeResult\n             * @static\n             * @param {proto.IUnsubscribeResult=} [properties] Properties to set\n             * @returns {proto.UnsubscribeResult} UnsubscribeResult instance\n             */\n            UnsubscribeResult.create = function create(properties) {\n                return new UnsubscribeResult(properties);\n            };\n    \n            /**\n             * Encodes the specified UnsubscribeResult message. Does not implicitly {@link proto.UnsubscribeResult.verify|verify} messages.\n             * @function encode\n             * @memberof proto.UnsubscribeResult\n             * @static\n             * @param {proto.IUnsubscribeResult} message UnsubscribeResult message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            UnsubscribeResult.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified UnsubscribeResult message, length delimited. Does not implicitly {@link proto.UnsubscribeResult.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.UnsubscribeResult\n             * @static\n             * @param {proto.IUnsubscribeResult} message UnsubscribeResult message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            UnsubscribeResult.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes an UnsubscribeResult message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.UnsubscribeResult\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.UnsubscribeResult} UnsubscribeResult\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            UnsubscribeResult.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UnsubscribeResult();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes an UnsubscribeResult message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.UnsubscribeResult\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.UnsubscribeResult} UnsubscribeResult\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            UnsubscribeResult.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies an UnsubscribeResult message.\n             * @function verify\n             * @memberof proto.UnsubscribeResult\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            UnsubscribeResult.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                return null;\n            };\n    \n            /**\n             * Creates an UnsubscribeResult message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.UnsubscribeResult\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.UnsubscribeResult} UnsubscribeResult\n             */\n            UnsubscribeResult.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.UnsubscribeResult)\n                    return object;\n                return new $root.proto.UnsubscribeResult();\n            };\n    \n            /**\n             * Creates a plain object from an UnsubscribeResult message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.UnsubscribeResult\n             * @static\n             * @param {proto.UnsubscribeResult} message UnsubscribeResult\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            UnsubscribeResult.toObject = function toObject() {\n                return {};\n            };\n    \n            /**\n             * Converts this UnsubscribeResult to JSON.\n             * @function toJSON\n             * @memberof proto.UnsubscribeResult\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            UnsubscribeResult.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return UnsubscribeResult;\n        })();\n    \n        proto.PublishRequest = (function() {\n    \n            /**\n             * Properties of a PublishRequest.\n             * @memberof proto\n             * @interface IPublishRequest\n             * @property {string|null} [channel] PublishRequest channel\n             * @property {Uint8Array|null} [data] PublishRequest data\n             */\n    \n            /**\n             * Constructs a new PublishRequest.\n             * @memberof proto\n             * @classdesc Represents a PublishRequest.\n             * @implements IPublishRequest\n             * @constructor\n             * @param {proto.IPublishRequest=} [properties] Properties to set\n             */\n            function PublishRequest(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * PublishRequest channel.\n             * @member {string} channel\n             * @memberof proto.PublishRequest\n             * @instance\n             */\n            PublishRequest.prototype.channel = "";\n    \n            /**\n             * PublishRequest data.\n             * @member {Uint8Array} data\n             * @memberof proto.PublishRequest\n             * @instance\n             */\n            PublishRequest.prototype.data = $util.newBuffer([]);\n    \n            /**\n             * Creates a new PublishRequest instance using the specified properties.\n             * @function create\n             * @memberof proto.PublishRequest\n             * @static\n             * @param {proto.IPublishRequest=} [properties] Properties to set\n             * @returns {proto.PublishRequest} PublishRequest instance\n             */\n            PublishRequest.create = function create(properties) {\n                return new PublishRequest(properties);\n            };\n    \n            /**\n             * Encodes the specified PublishRequest message. Does not implicitly {@link proto.PublishRequest.verify|verify} messages.\n             * @function encode\n             * @memberof proto.PublishRequest\n             * @static\n             * @param {proto.IPublishRequest} message PublishRequest message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PublishRequest.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);\n                if (message.data != null && message.hasOwnProperty("data"))\n                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified PublishRequest message, length delimited. Does not implicitly {@link proto.PublishRequest.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.PublishRequest\n             * @static\n             * @param {proto.IPublishRequest} message PublishRequest message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PublishRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a PublishRequest message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.PublishRequest\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.PublishRequest} PublishRequest\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PublishRequest.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PublishRequest();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.channel = reader.string();\n                        break;\n                    case 2:\n                        message.data = reader.bytes();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a PublishRequest message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.PublishRequest\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.PublishRequest} PublishRequest\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PublishRequest.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a PublishRequest message.\n             * @function verify\n             * @memberof proto.PublishRequest\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            PublishRequest.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    if (!$util.isString(message.channel))\n                        return "channel: string expected";\n                if (message.data != null && message.hasOwnProperty("data"))\n                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))\n                        return "data: buffer expected";\n                return null;\n            };\n    \n            /**\n             * Creates a PublishRequest message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.PublishRequest\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.PublishRequest} PublishRequest\n             */\n            PublishRequest.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.PublishRequest)\n                    return object;\n                var message = new $root.proto.PublishRequest();\n                if (object.channel != null)\n                    message.channel = String(object.channel);\n                if (object.data != null)\n                    if (typeof object.data === "string")\n                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);\n                    else if (object.data.length)\n                        message.data = object.data;\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a PublishRequest message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.PublishRequest\n             * @static\n             * @param {proto.PublishRequest} message PublishRequest\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            PublishRequest.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.channel = "";\n                    object.data = options.bytes === String ? "" : [];\n                }\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    object.channel = message.channel;\n                if (message.data != null && message.hasOwnProperty("data"))\n                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;\n                return object;\n            };\n    \n            /**\n             * Converts this PublishRequest to JSON.\n             * @function toJSON\n             * @memberof proto.PublishRequest\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            PublishRequest.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return PublishRequest;\n        })();\n    \n        proto.PublishResponse = (function() {\n    \n            /**\n             * Properties of a PublishResponse.\n             * @memberof proto\n             * @interface IPublishResponse\n             * @property {proto.IError|null} [error] PublishResponse error\n             * @property {proto.IPublishResult|null} [result] PublishResponse result\n             */\n    \n            /**\n             * Constructs a new PublishResponse.\n             * @memberof proto\n             * @classdesc Represents a PublishResponse.\n             * @implements IPublishResponse\n             * @constructor\n             * @param {proto.IPublishResponse=} [properties] Properties to set\n             */\n            function PublishResponse(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * PublishResponse error.\n             * @member {proto.IError|null|undefined} error\n             * @memberof proto.PublishResponse\n             * @instance\n             */\n            PublishResponse.prototype.error = null;\n    \n            /**\n             * PublishResponse result.\n             * @member {proto.IPublishResult|null|undefined} result\n             * @memberof proto.PublishResponse\n             * @instance\n             */\n            PublishResponse.prototype.result = null;\n    \n            /**\n             * Creates a new PublishResponse instance using the specified properties.\n             * @function create\n             * @memberof proto.PublishResponse\n             * @static\n             * @param {proto.IPublishResponse=} [properties] Properties to set\n             * @returns {proto.PublishResponse} PublishResponse instance\n             */\n            PublishResponse.create = function create(properties) {\n                return new PublishResponse(properties);\n            };\n    \n            /**\n             * Encodes the specified PublishResponse message. Does not implicitly {@link proto.PublishResponse.verify|verify} messages.\n             * @function encode\n             * @memberof proto.PublishResponse\n             * @static\n             * @param {proto.IPublishResponse} message PublishResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PublishResponse.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.error != null && message.hasOwnProperty("error"))\n                    $root.proto.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                if (message.result != null && message.hasOwnProperty("result"))\n                    $root.proto.PublishResult.encode(message.result, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified PublishResponse message, length delimited. Does not implicitly {@link proto.PublishResponse.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.PublishResponse\n             * @static\n             * @param {proto.IPublishResponse} message PublishResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PublishResponse.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a PublishResponse message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.PublishResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.PublishResponse} PublishResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PublishResponse.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PublishResponse();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.error = $root.proto.Error.decode(reader, reader.uint32());\n                        break;\n                    case 2:\n                        message.result = $root.proto.PublishResult.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a PublishResponse message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.PublishResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.PublishResponse} PublishResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PublishResponse.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a PublishResponse message.\n             * @function verify\n             * @memberof proto.PublishResponse\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            PublishResponse.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.error != null && message.hasOwnProperty("error")) {\n                    var error = $root.proto.Error.verify(message.error);\n                    if (error)\n                        return "error." + error;\n                }\n                if (message.result != null && message.hasOwnProperty("result")) {\n                    var error = $root.proto.PublishResult.verify(message.result);\n                    if (error)\n                        return "result." + error;\n                }\n                return null;\n            };\n    \n            /**\n             * Creates a PublishResponse message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.PublishResponse\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.PublishResponse} PublishResponse\n             */\n            PublishResponse.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.PublishResponse)\n                    return object;\n                var message = new $root.proto.PublishResponse();\n                if (object.error != null) {\n                    if (typeof object.error !== "object")\n                        throw TypeError(".proto.PublishResponse.error: object expected");\n                    message.error = $root.proto.Error.fromObject(object.error);\n                }\n                if (object.result != null) {\n                    if (typeof object.result !== "object")\n                        throw TypeError(".proto.PublishResponse.result: object expected");\n                    message.result = $root.proto.PublishResult.fromObject(object.result);\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a PublishResponse message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.PublishResponse\n             * @static\n             * @param {proto.PublishResponse} message PublishResponse\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            PublishResponse.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.error = null;\n                    object.result = null;\n                }\n                if (message.error != null && message.hasOwnProperty("error"))\n                    object.error = $root.proto.Error.toObject(message.error, options);\n                if (message.result != null && message.hasOwnProperty("result"))\n                    object.result = $root.proto.PublishResult.toObject(message.result, options);\n                return object;\n            };\n    \n            /**\n             * Converts this PublishResponse to JSON.\n             * @function toJSON\n             * @memberof proto.PublishResponse\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            PublishResponse.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return PublishResponse;\n        })();\n    \n        proto.PublishResult = (function() {\n    \n            /**\n             * Properties of a PublishResult.\n             * @memberof proto\n             * @interface IPublishResult\n             */\n    \n            /**\n             * Constructs a new PublishResult.\n             * @memberof proto\n             * @classdesc Represents a PublishResult.\n             * @implements IPublishResult\n             * @constructor\n             * @param {proto.IPublishResult=} [properties] Properties to set\n             */\n            function PublishResult(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * Creates a new PublishResult instance using the specified properties.\n             * @function create\n             * @memberof proto.PublishResult\n             * @static\n             * @param {proto.IPublishResult=} [properties] Properties to set\n             * @returns {proto.PublishResult} PublishResult instance\n             */\n            PublishResult.create = function create(properties) {\n                return new PublishResult(properties);\n            };\n    \n            /**\n             * Encodes the specified PublishResult message. Does not implicitly {@link proto.PublishResult.verify|verify} messages.\n             * @function encode\n             * @memberof proto.PublishResult\n             * @static\n             * @param {proto.IPublishResult} message PublishResult message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PublishResult.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified PublishResult message, length delimited. Does not implicitly {@link proto.PublishResult.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.PublishResult\n             * @static\n             * @param {proto.IPublishResult} message PublishResult message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PublishResult.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a PublishResult message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.PublishResult\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.PublishResult} PublishResult\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PublishResult.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PublishResult();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a PublishResult message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.PublishResult\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.PublishResult} PublishResult\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PublishResult.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a PublishResult message.\n             * @function verify\n             * @memberof proto.PublishResult\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            PublishResult.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                return null;\n            };\n    \n            /**\n             * Creates a PublishResult message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.PublishResult\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.PublishResult} PublishResult\n             */\n            PublishResult.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.PublishResult)\n                    return object;\n                return new $root.proto.PublishResult();\n            };\n    \n            /**\n             * Creates a plain object from a PublishResult message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.PublishResult\n             * @static\n             * @param {proto.PublishResult} message PublishResult\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            PublishResult.toObject = function toObject() {\n                return {};\n            };\n    \n            /**\n             * Converts this PublishResult to JSON.\n             * @function toJSON\n             * @memberof proto.PublishResult\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            PublishResult.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return PublishResult;\n        })();\n    \n        proto.PresenceRequest = (function() {\n    \n            /**\n             * Properties of a PresenceRequest.\n             * @memberof proto\n             * @interface IPresenceRequest\n             * @property {string|null} [channel] PresenceRequest channel\n             */\n    \n            /**\n             * Constructs a new PresenceRequest.\n             * @memberof proto\n             * @classdesc Represents a PresenceRequest.\n             * @implements IPresenceRequest\n             * @constructor\n             * @param {proto.IPresenceRequest=} [properties] Properties to set\n             */\n            function PresenceRequest(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * PresenceRequest channel.\n             * @member {string} channel\n             * @memberof proto.PresenceRequest\n             * @instance\n             */\n            PresenceRequest.prototype.channel = "";\n    \n            /**\n             * Creates a new PresenceRequest instance using the specified properties.\n             * @function create\n             * @memberof proto.PresenceRequest\n             * @static\n             * @param {proto.IPresenceRequest=} [properties] Properties to set\n             * @returns {proto.PresenceRequest} PresenceRequest instance\n             */\n            PresenceRequest.create = function create(properties) {\n                return new PresenceRequest(properties);\n            };\n    \n            /**\n             * Encodes the specified PresenceRequest message. Does not implicitly {@link proto.PresenceRequest.verify|verify} messages.\n             * @function encode\n             * @memberof proto.PresenceRequest\n             * @static\n             * @param {proto.IPresenceRequest} message PresenceRequest message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PresenceRequest.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified PresenceRequest message, length delimited. Does not implicitly {@link proto.PresenceRequest.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.PresenceRequest\n             * @static\n             * @param {proto.IPresenceRequest} message PresenceRequest message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PresenceRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a PresenceRequest message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.PresenceRequest\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.PresenceRequest} PresenceRequest\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PresenceRequest.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PresenceRequest();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.channel = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a PresenceRequest message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.PresenceRequest\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.PresenceRequest} PresenceRequest\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PresenceRequest.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a PresenceRequest message.\n             * @function verify\n             * @memberof proto.PresenceRequest\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            PresenceRequest.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    if (!$util.isString(message.channel))\n                        return "channel: string expected";\n                return null;\n            };\n    \n            /**\n             * Creates a PresenceRequest message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.PresenceRequest\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.PresenceRequest} PresenceRequest\n             */\n            PresenceRequest.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.PresenceRequest)\n                    return object;\n                var message = new $root.proto.PresenceRequest();\n                if (object.channel != null)\n                    message.channel = String(object.channel);\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a PresenceRequest message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.PresenceRequest\n             * @static\n             * @param {proto.PresenceRequest} message PresenceRequest\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            PresenceRequest.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.channel = "";\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    object.channel = message.channel;\n                return object;\n            };\n    \n            /**\n             * Converts this PresenceRequest to JSON.\n             * @function toJSON\n             * @memberof proto.PresenceRequest\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            PresenceRequest.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return PresenceRequest;\n        })();\n    \n        proto.PresenceResponse = (function() {\n    \n            /**\n             * Properties of a PresenceResponse.\n             * @memberof proto\n             * @interface IPresenceResponse\n             * @property {proto.IError|null} [error] PresenceResponse error\n             * @property {proto.IPresenceResult|null} [result] PresenceResponse result\n             */\n    \n            /**\n             * Constructs a new PresenceResponse.\n             * @memberof proto\n             * @classdesc Represents a PresenceResponse.\n             * @implements IPresenceResponse\n             * @constructor\n             * @param {proto.IPresenceResponse=} [properties] Properties to set\n             */\n            function PresenceResponse(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * PresenceResponse error.\n             * @member {proto.IError|null|undefined} error\n             * @memberof proto.PresenceResponse\n             * @instance\n             */\n            PresenceResponse.prototype.error = null;\n    \n            /**\n             * PresenceResponse result.\n             * @member {proto.IPresenceResult|null|undefined} result\n             * @memberof proto.PresenceResponse\n             * @instance\n             */\n            PresenceResponse.prototype.result = null;\n    \n            /**\n             * Creates a new PresenceResponse instance using the specified properties.\n             * @function create\n             * @memberof proto.PresenceResponse\n             * @static\n             * @param {proto.IPresenceResponse=} [properties] Properties to set\n             * @returns {proto.PresenceResponse} PresenceResponse instance\n             */\n            PresenceResponse.create = function create(properties) {\n                return new PresenceResponse(properties);\n            };\n    \n            /**\n             * Encodes the specified PresenceResponse message. Does not implicitly {@link proto.PresenceResponse.verify|verify} messages.\n             * @function encode\n             * @memberof proto.PresenceResponse\n             * @static\n             * @param {proto.IPresenceResponse} message PresenceResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PresenceResponse.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.error != null && message.hasOwnProperty("error"))\n                    $root.proto.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                if (message.result != null && message.hasOwnProperty("result"))\n                    $root.proto.PresenceResult.encode(message.result, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified PresenceResponse message, length delimited. Does not implicitly {@link proto.PresenceResponse.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.PresenceResponse\n             * @static\n             * @param {proto.IPresenceResponse} message PresenceResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PresenceResponse.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a PresenceResponse message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.PresenceResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.PresenceResponse} PresenceResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PresenceResponse.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PresenceResponse();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.error = $root.proto.Error.decode(reader, reader.uint32());\n                        break;\n                    case 2:\n                        message.result = $root.proto.PresenceResult.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a PresenceResponse message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.PresenceResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.PresenceResponse} PresenceResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PresenceResponse.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a PresenceResponse message.\n             * @function verify\n             * @memberof proto.PresenceResponse\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            PresenceResponse.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.error != null && message.hasOwnProperty("error")) {\n                    var error = $root.proto.Error.verify(message.error);\n                    if (error)\n                        return "error." + error;\n                }\n                if (message.result != null && message.hasOwnProperty("result")) {\n                    var error = $root.proto.PresenceResult.verify(message.result);\n                    if (error)\n                        return "result." + error;\n                }\n                return null;\n            };\n    \n            /**\n             * Creates a PresenceResponse message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.PresenceResponse\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.PresenceResponse} PresenceResponse\n             */\n            PresenceResponse.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.PresenceResponse)\n                    return object;\n                var message = new $root.proto.PresenceResponse();\n                if (object.error != null) {\n                    if (typeof object.error !== "object")\n                        throw TypeError(".proto.PresenceResponse.error: object expected");\n                    message.error = $root.proto.Error.fromObject(object.error);\n                }\n                if (object.result != null) {\n                    if (typeof object.result !== "object")\n                        throw TypeError(".proto.PresenceResponse.result: object expected");\n                    message.result = $root.proto.PresenceResult.fromObject(object.result);\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a PresenceResponse message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.PresenceResponse\n             * @static\n             * @param {proto.PresenceResponse} message PresenceResponse\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            PresenceResponse.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.error = null;\n                    object.result = null;\n                }\n                if (message.error != null && message.hasOwnProperty("error"))\n                    object.error = $root.proto.Error.toObject(message.error, options);\n                if (message.result != null && message.hasOwnProperty("result"))\n                    object.result = $root.proto.PresenceResult.toObject(message.result, options);\n                return object;\n            };\n    \n            /**\n             * Converts this PresenceResponse to JSON.\n             * @function toJSON\n             * @memberof proto.PresenceResponse\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            PresenceResponse.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return PresenceResponse;\n        })();\n    \n        proto.PresenceResult = (function() {\n    \n            /**\n             * Properties of a PresenceResult.\n             * @memberof proto\n             * @interface IPresenceResult\n             * @property {Object.<string,proto.IClientInfo>|null} [presence] PresenceResult presence\n             */\n    \n            /**\n             * Constructs a new PresenceResult.\n             * @memberof proto\n             * @classdesc Represents a PresenceResult.\n             * @implements IPresenceResult\n             * @constructor\n             * @param {proto.IPresenceResult=} [properties] Properties to set\n             */\n            function PresenceResult(properties) {\n                this.presence = {};\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * PresenceResult presence.\n             * @member {Object.<string,proto.IClientInfo>} presence\n             * @memberof proto.PresenceResult\n             * @instance\n             */\n            PresenceResult.prototype.presence = $util.emptyObject;\n    \n            /**\n             * Creates a new PresenceResult instance using the specified properties.\n             * @function create\n             * @memberof proto.PresenceResult\n             * @static\n             * @param {proto.IPresenceResult=} [properties] Properties to set\n             * @returns {proto.PresenceResult} PresenceResult instance\n             */\n            PresenceResult.create = function create(properties) {\n                return new PresenceResult(properties);\n            };\n    \n            /**\n             * Encodes the specified PresenceResult message. Does not implicitly {@link proto.PresenceResult.verify|verify} messages.\n             * @function encode\n             * @memberof proto.PresenceResult\n             * @static\n             * @param {proto.IPresenceResult} message PresenceResult message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PresenceResult.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.presence != null && message.hasOwnProperty("presence"))\n                    for (var keys = Object.keys(message.presence), i = 0; i < keys.length; ++i) {\n                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                        $root.proto.ClientInfo.encode(message.presence[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n                    }\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified PresenceResult message, length delimited. Does not implicitly {@link proto.PresenceResult.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.PresenceResult\n             * @static\n             * @param {proto.IPresenceResult} message PresenceResult message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PresenceResult.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a PresenceResult message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.PresenceResult\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.PresenceResult} PresenceResult\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PresenceResult.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PresenceResult(), key;\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        reader.skip().pos++;\n                        if (message.presence === $util.emptyObject)\n                            message.presence = {};\n                        key = reader.string();\n                        reader.pos++;\n                        message.presence[key] = $root.proto.ClientInfo.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a PresenceResult message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.PresenceResult\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.PresenceResult} PresenceResult\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PresenceResult.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a PresenceResult message.\n             * @function verify\n             * @memberof proto.PresenceResult\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            PresenceResult.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.presence != null && message.hasOwnProperty("presence")) {\n                    if (!$util.isObject(message.presence))\n                        return "presence: object expected";\n                    var key = Object.keys(message.presence);\n                    for (var i = 0; i < key.length; ++i) {\n                        var error = $root.proto.ClientInfo.verify(message.presence[key[i]]);\n                        if (error)\n                            return "presence." + error;\n                    }\n                }\n                return null;\n            };\n    \n            /**\n             * Creates a PresenceResult message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.PresenceResult\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.PresenceResult} PresenceResult\n             */\n            PresenceResult.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.PresenceResult)\n                    return object;\n                var message = new $root.proto.PresenceResult();\n                if (object.presence) {\n                    if (typeof object.presence !== "object")\n                        throw TypeError(".proto.PresenceResult.presence: object expected");\n                    message.presence = {};\n                    for (var keys = Object.keys(object.presence), i = 0; i < keys.length; ++i) {\n                        if (typeof object.presence[keys[i]] !== "object")\n                            throw TypeError(".proto.PresenceResult.presence: object expected");\n                        message.presence[keys[i]] = $root.proto.ClientInfo.fromObject(object.presence[keys[i]]);\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a PresenceResult message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.PresenceResult\n             * @static\n             * @param {proto.PresenceResult} message PresenceResult\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            PresenceResult.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.objects || options.defaults)\n                    object.presence = {};\n                var keys2;\n                if (message.presence && (keys2 = Object.keys(message.presence)).length) {\n                    object.presence = {};\n                    for (var j = 0; j < keys2.length; ++j)\n                        object.presence[keys2[j]] = $root.proto.ClientInfo.toObject(message.presence[keys2[j]], options);\n                }\n                return object;\n            };\n    \n            /**\n             * Converts this PresenceResult to JSON.\n             * @function toJSON\n             * @memberof proto.PresenceResult\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            PresenceResult.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return PresenceResult;\n        })();\n    \n        proto.PresenceStatsRequest = (function() {\n    \n            /**\n             * Properties of a PresenceStatsRequest.\n             * @memberof proto\n             * @interface IPresenceStatsRequest\n             * @property {string|null} [channel] PresenceStatsRequest channel\n             */\n    \n            /**\n             * Constructs a new PresenceStatsRequest.\n             * @memberof proto\n             * @classdesc Represents a PresenceStatsRequest.\n             * @implements IPresenceStatsRequest\n             * @constructor\n             * @param {proto.IPresenceStatsRequest=} [properties] Properties to set\n             */\n            function PresenceStatsRequest(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * PresenceStatsRequest channel.\n             * @member {string} channel\n             * @memberof proto.PresenceStatsRequest\n             * @instance\n             */\n            PresenceStatsRequest.prototype.channel = "";\n    \n            /**\n             * Creates a new PresenceStatsRequest instance using the specified properties.\n             * @function create\n             * @memberof proto.PresenceStatsRequest\n             * @static\n             * @param {proto.IPresenceStatsRequest=} [properties] Properties to set\n             * @returns {proto.PresenceStatsRequest} PresenceStatsRequest instance\n             */\n            PresenceStatsRequest.create = function create(properties) {\n                return new PresenceStatsRequest(properties);\n            };\n    \n            /**\n             * Encodes the specified PresenceStatsRequest message. Does not implicitly {@link proto.PresenceStatsRequest.verify|verify} messages.\n             * @function encode\n             * @memberof proto.PresenceStatsRequest\n             * @static\n             * @param {proto.IPresenceStatsRequest} message PresenceStatsRequest message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PresenceStatsRequest.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified PresenceStatsRequest message, length delimited. Does not implicitly {@link proto.PresenceStatsRequest.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.PresenceStatsRequest\n             * @static\n             * @param {proto.IPresenceStatsRequest} message PresenceStatsRequest message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PresenceStatsRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a PresenceStatsRequest message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.PresenceStatsRequest\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.PresenceStatsRequest} PresenceStatsRequest\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PresenceStatsRequest.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PresenceStatsRequest();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.channel = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a PresenceStatsRequest message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.PresenceStatsRequest\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.PresenceStatsRequest} PresenceStatsRequest\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PresenceStatsRequest.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a PresenceStatsRequest message.\n             * @function verify\n             * @memberof proto.PresenceStatsRequest\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            PresenceStatsRequest.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    if (!$util.isString(message.channel))\n                        return "channel: string expected";\n                return null;\n            };\n    \n            /**\n             * Creates a PresenceStatsRequest message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.PresenceStatsRequest\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.PresenceStatsRequest} PresenceStatsRequest\n             */\n            PresenceStatsRequest.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.PresenceStatsRequest)\n                    return object;\n                var message = new $root.proto.PresenceStatsRequest();\n                if (object.channel != null)\n                    message.channel = String(object.channel);\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a PresenceStatsRequest message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.PresenceStatsRequest\n             * @static\n             * @param {proto.PresenceStatsRequest} message PresenceStatsRequest\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            PresenceStatsRequest.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.channel = "";\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    object.channel = message.channel;\n                return object;\n            };\n    \n            /**\n             * Converts this PresenceStatsRequest to JSON.\n             * @function toJSON\n             * @memberof proto.PresenceStatsRequest\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            PresenceStatsRequest.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return PresenceStatsRequest;\n        })();\n    \n        proto.PresenceStatsResponse = (function() {\n    \n            /**\n             * Properties of a PresenceStatsResponse.\n             * @memberof proto\n             * @interface IPresenceStatsResponse\n             * @property {proto.IError|null} [error] PresenceStatsResponse error\n             * @property {proto.IPresenceStatsResult|null} [result] PresenceStatsResponse result\n             */\n    \n            /**\n             * Constructs a new PresenceStatsResponse.\n             * @memberof proto\n             * @classdesc Represents a PresenceStatsResponse.\n             * @implements IPresenceStatsResponse\n             * @constructor\n             * @param {proto.IPresenceStatsResponse=} [properties] Properties to set\n             */\n            function PresenceStatsResponse(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * PresenceStatsResponse error.\n             * @member {proto.IError|null|undefined} error\n             * @memberof proto.PresenceStatsResponse\n             * @instance\n             */\n            PresenceStatsResponse.prototype.error = null;\n    \n            /**\n             * PresenceStatsResponse result.\n             * @member {proto.IPresenceStatsResult|null|undefined} result\n             * @memberof proto.PresenceStatsResponse\n             * @instance\n             */\n            PresenceStatsResponse.prototype.result = null;\n    \n            /**\n             * Creates a new PresenceStatsResponse instance using the specified properties.\n             * @function create\n             * @memberof proto.PresenceStatsResponse\n             * @static\n             * @param {proto.IPresenceStatsResponse=} [properties] Properties to set\n             * @returns {proto.PresenceStatsResponse} PresenceStatsResponse instance\n             */\n            PresenceStatsResponse.create = function create(properties) {\n                return new PresenceStatsResponse(properties);\n            };\n    \n            /**\n             * Encodes the specified PresenceStatsResponse message. Does not implicitly {@link proto.PresenceStatsResponse.verify|verify} messages.\n             * @function encode\n             * @memberof proto.PresenceStatsResponse\n             * @static\n             * @param {proto.IPresenceStatsResponse} message PresenceStatsResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PresenceStatsResponse.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.error != null && message.hasOwnProperty("error"))\n                    $root.proto.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                if (message.result != null && message.hasOwnProperty("result"))\n                    $root.proto.PresenceStatsResult.encode(message.result, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified PresenceStatsResponse message, length delimited. Does not implicitly {@link proto.PresenceStatsResponse.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.PresenceStatsResponse\n             * @static\n             * @param {proto.IPresenceStatsResponse} message PresenceStatsResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PresenceStatsResponse.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a PresenceStatsResponse message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.PresenceStatsResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.PresenceStatsResponse} PresenceStatsResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PresenceStatsResponse.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PresenceStatsResponse();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.error = $root.proto.Error.decode(reader, reader.uint32());\n                        break;\n                    case 2:\n                        message.result = $root.proto.PresenceStatsResult.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a PresenceStatsResponse message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.PresenceStatsResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.PresenceStatsResponse} PresenceStatsResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PresenceStatsResponse.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a PresenceStatsResponse message.\n             * @function verify\n             * @memberof proto.PresenceStatsResponse\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            PresenceStatsResponse.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.error != null && message.hasOwnProperty("error")) {\n                    var error = $root.proto.Error.verify(message.error);\n                    if (error)\n                        return "error." + error;\n                }\n                if (message.result != null && message.hasOwnProperty("result")) {\n                    var error = $root.proto.PresenceStatsResult.verify(message.result);\n                    if (error)\n                        return "result." + error;\n                }\n                return null;\n            };\n    \n            /**\n             * Creates a PresenceStatsResponse message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.PresenceStatsResponse\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.PresenceStatsResponse} PresenceStatsResponse\n             */\n            PresenceStatsResponse.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.PresenceStatsResponse)\n                    return object;\n                var message = new $root.proto.PresenceStatsResponse();\n                if (object.error != null) {\n                    if (typeof object.error !== "object")\n                        throw TypeError(".proto.PresenceStatsResponse.error: object expected");\n                    message.error = $root.proto.Error.fromObject(object.error);\n                }\n                if (object.result != null) {\n                    if (typeof object.result !== "object")\n                        throw TypeError(".proto.PresenceStatsResponse.result: object expected");\n                    message.result = $root.proto.PresenceStatsResult.fromObject(object.result);\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a PresenceStatsResponse message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.PresenceStatsResponse\n             * @static\n             * @param {proto.PresenceStatsResponse} message PresenceStatsResponse\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            PresenceStatsResponse.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.error = null;\n                    object.result = null;\n                }\n                if (message.error != null && message.hasOwnProperty("error"))\n                    object.error = $root.proto.Error.toObject(message.error, options);\n                if (message.result != null && message.hasOwnProperty("result"))\n                    object.result = $root.proto.PresenceStatsResult.toObject(message.result, options);\n                return object;\n            };\n    \n            /**\n             * Converts this PresenceStatsResponse to JSON.\n             * @function toJSON\n             * @memberof proto.PresenceStatsResponse\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            PresenceStatsResponse.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return PresenceStatsResponse;\n        })();\n    \n        proto.PresenceStatsResult = (function() {\n    \n            /**\n             * Properties of a PresenceStatsResult.\n             * @memberof proto\n             * @interface IPresenceStatsResult\n             * @property {number|null} [numClients] PresenceStatsResult numClients\n             * @property {number|null} [numUsers] PresenceStatsResult numUsers\n             */\n    \n            /**\n             * Constructs a new PresenceStatsResult.\n             * @memberof proto\n             * @classdesc Represents a PresenceStatsResult.\n             * @implements IPresenceStatsResult\n             * @constructor\n             * @param {proto.IPresenceStatsResult=} [properties] Properties to set\n             */\n            function PresenceStatsResult(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * PresenceStatsResult numClients.\n             * @member {number} numClients\n             * @memberof proto.PresenceStatsResult\n             * @instance\n             */\n            PresenceStatsResult.prototype.numClients = 0;\n    \n            /**\n             * PresenceStatsResult numUsers.\n             * @member {number} numUsers\n             * @memberof proto.PresenceStatsResult\n             * @instance\n             */\n            PresenceStatsResult.prototype.numUsers = 0;\n    \n            /**\n             * Creates a new PresenceStatsResult instance using the specified properties.\n             * @function create\n             * @memberof proto.PresenceStatsResult\n             * @static\n             * @param {proto.IPresenceStatsResult=} [properties] Properties to set\n             * @returns {proto.PresenceStatsResult} PresenceStatsResult instance\n             */\n            PresenceStatsResult.create = function create(properties) {\n                return new PresenceStatsResult(properties);\n            };\n    \n            /**\n             * Encodes the specified PresenceStatsResult message. Does not implicitly {@link proto.PresenceStatsResult.verify|verify} messages.\n             * @function encode\n             * @memberof proto.PresenceStatsResult\n             * @static\n             * @param {proto.IPresenceStatsResult} message PresenceStatsResult message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PresenceStatsResult.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.numClients != null && message.hasOwnProperty("numClients"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.numClients);\n                if (message.numUsers != null && message.hasOwnProperty("numUsers"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.numUsers);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified PresenceStatsResult message, length delimited. Does not implicitly {@link proto.PresenceStatsResult.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.PresenceStatsResult\n             * @static\n             * @param {proto.IPresenceStatsResult} message PresenceStatsResult message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PresenceStatsResult.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a PresenceStatsResult message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.PresenceStatsResult\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.PresenceStatsResult} PresenceStatsResult\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PresenceStatsResult.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PresenceStatsResult();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.numClients = reader.uint32();\n                        break;\n                    case 2:\n                        message.numUsers = reader.uint32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a PresenceStatsResult message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.PresenceStatsResult\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.PresenceStatsResult} PresenceStatsResult\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PresenceStatsResult.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a PresenceStatsResult message.\n             * @function verify\n             * @memberof proto.PresenceStatsResult\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            PresenceStatsResult.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.numClients != null && message.hasOwnProperty("numClients"))\n                    if (!$util.isInteger(message.numClients))\n                        return "numClients: integer expected";\n                if (message.numUsers != null && message.hasOwnProperty("numUsers"))\n                    if (!$util.isInteger(message.numUsers))\n                        return "numUsers: integer expected";\n                return null;\n            };\n    \n            /**\n             * Creates a PresenceStatsResult message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.PresenceStatsResult\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.PresenceStatsResult} PresenceStatsResult\n             */\n            PresenceStatsResult.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.PresenceStatsResult)\n                    return object;\n                var message = new $root.proto.PresenceStatsResult();\n                if (object.numClients != null)\n                    message.numClients = object.numClients >>> 0;\n                if (object.numUsers != null)\n                    message.numUsers = object.numUsers >>> 0;\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a PresenceStatsResult message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.PresenceStatsResult\n             * @static\n             * @param {proto.PresenceStatsResult} message PresenceStatsResult\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            PresenceStatsResult.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.numClients = 0;\n                    object.numUsers = 0;\n                }\n                if (message.numClients != null && message.hasOwnProperty("numClients"))\n                    object.numClients = message.numClients;\n                if (message.numUsers != null && message.hasOwnProperty("numUsers"))\n                    object.numUsers = message.numUsers;\n                return object;\n            };\n    \n            /**\n             * Converts this PresenceStatsResult to JSON.\n             * @function toJSON\n             * @memberof proto.PresenceStatsResult\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            PresenceStatsResult.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return PresenceStatsResult;\n        })();\n    \n        proto.HistoryRequest = (function() {\n    \n            /**\n             * Properties of a HistoryRequest.\n             * @memberof proto\n             * @interface IHistoryRequest\n             * @property {string|null} [channel] HistoryRequest channel\n             */\n    \n            /**\n             * Constructs a new HistoryRequest.\n             * @memberof proto\n             * @classdesc Represents a HistoryRequest.\n             * @implements IHistoryRequest\n             * @constructor\n             * @param {proto.IHistoryRequest=} [properties] Properties to set\n             */\n            function HistoryRequest(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * HistoryRequest channel.\n             * @member {string} channel\n             * @memberof proto.HistoryRequest\n             * @instance\n             */\n            HistoryRequest.prototype.channel = "";\n    \n            /**\n             * Creates a new HistoryRequest instance using the specified properties.\n             * @function create\n             * @memberof proto.HistoryRequest\n             * @static\n             * @param {proto.IHistoryRequest=} [properties] Properties to set\n             * @returns {proto.HistoryRequest} HistoryRequest instance\n             */\n            HistoryRequest.create = function create(properties) {\n                return new HistoryRequest(properties);\n            };\n    \n            /**\n             * Encodes the specified HistoryRequest message. Does not implicitly {@link proto.HistoryRequest.verify|verify} messages.\n             * @function encode\n             * @memberof proto.HistoryRequest\n             * @static\n             * @param {proto.IHistoryRequest} message HistoryRequest message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            HistoryRequest.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified HistoryRequest message, length delimited. Does not implicitly {@link proto.HistoryRequest.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.HistoryRequest\n             * @static\n             * @param {proto.IHistoryRequest} message HistoryRequest message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            HistoryRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a HistoryRequest message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.HistoryRequest\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.HistoryRequest} HistoryRequest\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            HistoryRequest.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.HistoryRequest();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.channel = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a HistoryRequest message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.HistoryRequest\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.HistoryRequest} HistoryRequest\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            HistoryRequest.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a HistoryRequest message.\n             * @function verify\n             * @memberof proto.HistoryRequest\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            HistoryRequest.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    if (!$util.isString(message.channel))\n                        return "channel: string expected";\n                return null;\n            };\n    \n            /**\n             * Creates a HistoryRequest message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.HistoryRequest\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.HistoryRequest} HistoryRequest\n             */\n            HistoryRequest.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.HistoryRequest)\n                    return object;\n                var message = new $root.proto.HistoryRequest();\n                if (object.channel != null)\n                    message.channel = String(object.channel);\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a HistoryRequest message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.HistoryRequest\n             * @static\n             * @param {proto.HistoryRequest} message HistoryRequest\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            HistoryRequest.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.channel = "";\n                if (message.channel != null && message.hasOwnProperty("channel"))\n                    object.channel = message.channel;\n                return object;\n            };\n    \n            /**\n             * Converts this HistoryRequest to JSON.\n             * @function toJSON\n             * @memberof proto.HistoryRequest\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            HistoryRequest.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return HistoryRequest;\n        })();\n    \n        proto.HistoryResponse = (function() {\n    \n            /**\n             * Properties of a HistoryResponse.\n             * @memberof proto\n             * @interface IHistoryResponse\n             * @property {proto.IError|null} [error] HistoryResponse error\n             * @property {proto.IHistoryResult|null} [result] HistoryResponse result\n             */\n    \n            /**\n             * Constructs a new HistoryResponse.\n             * @memberof proto\n             * @classdesc Represents a HistoryResponse.\n             * @implements IHistoryResponse\n             * @constructor\n             * @param {proto.IHistoryResponse=} [properties] Properties to set\n             */\n            function HistoryResponse(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * HistoryResponse error.\n             * @member {proto.IError|null|undefined} error\n             * @memberof proto.HistoryResponse\n             * @instance\n             */\n            HistoryResponse.prototype.error = null;\n    \n            /**\n             * HistoryResponse result.\n             * @member {proto.IHistoryResult|null|undefined} result\n             * @memberof proto.HistoryResponse\n             * @instance\n             */\n            HistoryResponse.prototype.result = null;\n    \n            /**\n             * Creates a new HistoryResponse instance using the specified properties.\n             * @function create\n             * @memberof proto.HistoryResponse\n             * @static\n             * @param {proto.IHistoryResponse=} [properties] Properties to set\n             * @returns {proto.HistoryResponse} HistoryResponse instance\n             */\n            HistoryResponse.create = function create(properties) {\n                return new HistoryResponse(properties);\n            };\n    \n            /**\n             * Encodes the specified HistoryResponse message. Does not implicitly {@link proto.HistoryResponse.verify|verify} messages.\n             * @function encode\n             * @memberof proto.HistoryResponse\n             * @static\n             * @param {proto.IHistoryResponse} message HistoryResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            HistoryResponse.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.error != null && message.hasOwnProperty("error"))\n                    $root.proto.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                if (message.result != null && message.hasOwnProperty("result"))\n                    $root.proto.HistoryResult.encode(message.result, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified HistoryResponse message, length delimited. Does not implicitly {@link proto.HistoryResponse.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.HistoryResponse\n             * @static\n             * @param {proto.IHistoryResponse} message HistoryResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            HistoryResponse.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a HistoryResponse message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.HistoryResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.HistoryResponse} HistoryResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            HistoryResponse.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.HistoryResponse();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.error = $root.proto.Error.decode(reader, reader.uint32());\n                        break;\n                    case 2:\n                        message.result = $root.proto.HistoryResult.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a HistoryResponse message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.HistoryResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.HistoryResponse} HistoryResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            HistoryResponse.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a HistoryResponse message.\n             * @function verify\n             * @memberof proto.HistoryResponse\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            HistoryResponse.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.error != null && message.hasOwnProperty("error")) {\n                    var error = $root.proto.Error.verify(message.error);\n                    if (error)\n                        return "error." + error;\n                }\n                if (message.result != null && message.hasOwnProperty("result")) {\n                    var error = $root.proto.HistoryResult.verify(message.result);\n                    if (error)\n                        return "result." + error;\n                }\n                return null;\n            };\n    \n            /**\n             * Creates a HistoryResponse message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.HistoryResponse\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.HistoryResponse} HistoryResponse\n             */\n            HistoryResponse.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.HistoryResponse)\n                    return object;\n                var message = new $root.proto.HistoryResponse();\n                if (object.error != null) {\n                    if (typeof object.error !== "object")\n                        throw TypeError(".proto.HistoryResponse.error: object expected");\n                    message.error = $root.proto.Error.fromObject(object.error);\n                }\n                if (object.result != null) {\n                    if (typeof object.result !== "object")\n                        throw TypeError(".proto.HistoryResponse.result: object expected");\n                    message.result = $root.proto.HistoryResult.fromObject(object.result);\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a HistoryResponse message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.HistoryResponse\n             * @static\n             * @param {proto.HistoryResponse} message HistoryResponse\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            HistoryResponse.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.error = null;\n                    object.result = null;\n                }\n                if (message.error != null && message.hasOwnProperty("error"))\n                    object.error = $root.proto.Error.toObject(message.error, options);\n                if (message.result != null && message.hasOwnProperty("result"))\n                    object.result = $root.proto.HistoryResult.toObject(message.result, options);\n                return object;\n            };\n    \n            /**\n             * Converts this HistoryResponse to JSON.\n             * @function toJSON\n             * @memberof proto.HistoryResponse\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            HistoryResponse.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return HistoryResponse;\n        })();\n    \n        proto.HistoryResult = (function() {\n    \n            /**\n             * Properties of a HistoryResult.\n             * @memberof proto\n             * @interface IHistoryResult\n             * @property {Array.<proto.IPublication>|null} [publications] HistoryResult publications\n             */\n    \n            /**\n             * Constructs a new HistoryResult.\n             * @memberof proto\n             * @classdesc Represents a HistoryResult.\n             * @implements IHistoryResult\n             * @constructor\n             * @param {proto.IHistoryResult=} [properties] Properties to set\n             */\n            function HistoryResult(properties) {\n                this.publications = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * HistoryResult publications.\n             * @member {Array.<proto.IPublication>} publications\n             * @memberof proto.HistoryResult\n             * @instance\n             */\n            HistoryResult.prototype.publications = $util.emptyArray;\n    \n            /**\n             * Creates a new HistoryResult instance using the specified properties.\n             * @function create\n             * @memberof proto.HistoryResult\n             * @static\n             * @param {proto.IHistoryResult=} [properties] Properties to set\n             * @returns {proto.HistoryResult} HistoryResult instance\n             */\n            HistoryResult.create = function create(properties) {\n                return new HistoryResult(properties);\n            };\n    \n            /**\n             * Encodes the specified HistoryResult message. Does not implicitly {@link proto.HistoryResult.verify|verify} messages.\n             * @function encode\n             * @memberof proto.HistoryResult\n             * @static\n             * @param {proto.IHistoryResult} message HistoryResult message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            HistoryResult.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.publications != null && message.publications.length)\n                    for (var i = 0; i < message.publications.length; ++i)\n                        $root.proto.Publication.encode(message.publications[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified HistoryResult message, length delimited. Does not implicitly {@link proto.HistoryResult.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.HistoryResult\n             * @static\n             * @param {proto.IHistoryResult} message HistoryResult message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            HistoryResult.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a HistoryResult message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.HistoryResult\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.HistoryResult} HistoryResult\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            HistoryResult.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.HistoryResult();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        if (!(message.publications && message.publications.length))\n                            message.publications = [];\n                        message.publications.push($root.proto.Publication.decode(reader, reader.uint32()));\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a HistoryResult message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.HistoryResult\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.HistoryResult} HistoryResult\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            HistoryResult.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a HistoryResult message.\n             * @function verify\n             * @memberof proto.HistoryResult\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            HistoryResult.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.publications != null && message.hasOwnProperty("publications")) {\n                    if (!Array.isArray(message.publications))\n                        return "publications: array expected";\n                    for (var i = 0; i < message.publications.length; ++i) {\n                        var error = $root.proto.Publication.verify(message.publications[i]);\n                        if (error)\n                            return "publications." + error;\n                    }\n                }\n                return null;\n            };\n    \n            /**\n             * Creates a HistoryResult message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.HistoryResult\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.HistoryResult} HistoryResult\n             */\n            HistoryResult.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.HistoryResult)\n                    return object;\n                var message = new $root.proto.HistoryResult();\n                if (object.publications) {\n                    if (!Array.isArray(object.publications))\n                        throw TypeError(".proto.HistoryResult.publications: array expected");\n                    message.publications = [];\n                    for (var i = 0; i < object.publications.length; ++i) {\n                        if (typeof object.publications[i] !== "object")\n                            throw TypeError(".proto.HistoryResult.publications: object expected");\n                        message.publications[i] = $root.proto.Publication.fromObject(object.publications[i]);\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a HistoryResult message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.HistoryResult\n             * @static\n             * @param {proto.HistoryResult} message HistoryResult\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            HistoryResult.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.arrays || options.defaults)\n                    object.publications = [];\n                if (message.publications && message.publications.length) {\n                    object.publications = [];\n                    for (var j = 0; j < message.publications.length; ++j)\n                        object.publications[j] = $root.proto.Publication.toObject(message.publications[j], options);\n                }\n                return object;\n            };\n    \n            /**\n             * Converts this HistoryResult to JSON.\n             * @function toJSON\n             * @memberof proto.HistoryResult\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            HistoryResult.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return HistoryResult;\n        })();\n    \n        proto.PingRequest = (function() {\n    \n            /**\n             * Properties of a PingRequest.\n             * @memberof proto\n             * @interface IPingRequest\n             * @property {string|null} [data] PingRequest data\n             */\n    \n            /**\n             * Constructs a new PingRequest.\n             * @memberof proto\n             * @classdesc Represents a PingRequest.\n             * @implements IPingRequest\n             * @constructor\n             * @param {proto.IPingRequest=} [properties] Properties to set\n             */\n            function PingRequest(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * PingRequest data.\n             * @member {string} data\n             * @memberof proto.PingRequest\n             * @instance\n             */\n            PingRequest.prototype.data = "";\n    \n            /**\n             * Creates a new PingRequest instance using the specified properties.\n             * @function create\n             * @memberof proto.PingRequest\n             * @static\n             * @param {proto.IPingRequest=} [properties] Properties to set\n             * @returns {proto.PingRequest} PingRequest instance\n             */\n            PingRequest.create = function create(properties) {\n                return new PingRequest(properties);\n            };\n    \n            /**\n             * Encodes the specified PingRequest message. Does not implicitly {@link proto.PingRequest.verify|verify} messages.\n             * @function encode\n             * @memberof proto.PingRequest\n             * @static\n             * @param {proto.IPingRequest} message PingRequest message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PingRequest.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.data != null && message.hasOwnProperty("data"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.data);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified PingRequest message, length delimited. Does not implicitly {@link proto.PingRequest.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.PingRequest\n             * @static\n             * @param {proto.IPingRequest} message PingRequest message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PingRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a PingRequest message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.PingRequest\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.PingRequest} PingRequest\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PingRequest.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PingRequest();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.data = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a PingRequest message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.PingRequest\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.PingRequest} PingRequest\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PingRequest.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a PingRequest message.\n             * @function verify\n             * @memberof proto.PingRequest\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            PingRequest.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.data != null && message.hasOwnProperty("data"))\n                    if (!$util.isString(message.data))\n                        return "data: string expected";\n                return null;\n            };\n    \n            /**\n             * Creates a PingRequest message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.PingRequest\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.PingRequest} PingRequest\n             */\n            PingRequest.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.PingRequest)\n                    return object;\n                var message = new $root.proto.PingRequest();\n                if (object.data != null)\n                    message.data = String(object.data);\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a PingRequest message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.PingRequest\n             * @static\n             * @param {proto.PingRequest} message PingRequest\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            PingRequest.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.data = "";\n                if (message.data != null && message.hasOwnProperty("data"))\n                    object.data = message.data;\n                return object;\n            };\n    \n            /**\n             * Converts this PingRequest to JSON.\n             * @function toJSON\n             * @memberof proto.PingRequest\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            PingRequest.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return PingRequest;\n        })();\n    \n        proto.PingResponse = (function() {\n    \n            /**\n             * Properties of a PingResponse.\n             * @memberof proto\n             * @interface IPingResponse\n             * @property {proto.IError|null} [error] PingResponse error\n             * @property {proto.IPingResult|null} [result] PingResponse result\n             */\n    \n            /**\n             * Constructs a new PingResponse.\n             * @memberof proto\n             * @classdesc Represents a PingResponse.\n             * @implements IPingResponse\n             * @constructor\n             * @param {proto.IPingResponse=} [properties] Properties to set\n             */\n            function PingResponse(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * PingResponse error.\n             * @member {proto.IError|null|undefined} error\n             * @memberof proto.PingResponse\n             * @instance\n             */\n            PingResponse.prototype.error = null;\n    \n            /**\n             * PingResponse result.\n             * @member {proto.IPingResult|null|undefined} result\n             * @memberof proto.PingResponse\n             * @instance\n             */\n            PingResponse.prototype.result = null;\n    \n            /**\n             * Creates a new PingResponse instance using the specified properties.\n             * @function create\n             * @memberof proto.PingResponse\n             * @static\n             * @param {proto.IPingResponse=} [properties] Properties to set\n             * @returns {proto.PingResponse} PingResponse instance\n             */\n            PingResponse.create = function create(properties) {\n                return new PingResponse(properties);\n            };\n    \n            /**\n             * Encodes the specified PingResponse message. Does not implicitly {@link proto.PingResponse.verify|verify} messages.\n             * @function encode\n             * @memberof proto.PingResponse\n             * @static\n             * @param {proto.IPingResponse} message PingResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PingResponse.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.error != null && message.hasOwnProperty("error"))\n                    $root.proto.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                if (message.result != null && message.hasOwnProperty("result"))\n                    $root.proto.PingResult.encode(message.result, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified PingResponse message, length delimited. Does not implicitly {@link proto.PingResponse.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.PingResponse\n             * @static\n             * @param {proto.IPingResponse} message PingResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PingResponse.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a PingResponse message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.PingResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.PingResponse} PingResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PingResponse.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PingResponse();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.error = $root.proto.Error.decode(reader, reader.uint32());\n                        break;\n                    case 2:\n                        message.result = $root.proto.PingResult.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a PingResponse message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.PingResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.PingResponse} PingResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PingResponse.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a PingResponse message.\n             * @function verify\n             * @memberof proto.PingResponse\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            PingResponse.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.error != null && message.hasOwnProperty("error")) {\n                    var error = $root.proto.Error.verify(message.error);\n                    if (error)\n                        return "error." + error;\n                }\n                if (message.result != null && message.hasOwnProperty("result")) {\n                    var error = $root.proto.PingResult.verify(message.result);\n                    if (error)\n                        return "result." + error;\n                }\n                return null;\n            };\n    \n            /**\n             * Creates a PingResponse message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.PingResponse\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.PingResponse} PingResponse\n             */\n            PingResponse.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.PingResponse)\n                    return object;\n                var message = new $root.proto.PingResponse();\n                if (object.error != null) {\n                    if (typeof object.error !== "object")\n                        throw TypeError(".proto.PingResponse.error: object expected");\n                    message.error = $root.proto.Error.fromObject(object.error);\n                }\n                if (object.result != null) {\n                    if (typeof object.result !== "object")\n                        throw TypeError(".proto.PingResponse.result: object expected");\n                    message.result = $root.proto.PingResult.fromObject(object.result);\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a PingResponse message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.PingResponse\n             * @static\n             * @param {proto.PingResponse} message PingResponse\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            PingResponse.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.error = null;\n                    object.result = null;\n                }\n                if (message.error != null && message.hasOwnProperty("error"))\n                    object.error = $root.proto.Error.toObject(message.error, options);\n                if (message.result != null && message.hasOwnProperty("result"))\n                    object.result = $root.proto.PingResult.toObject(message.result, options);\n                return object;\n            };\n    \n            /**\n             * Converts this PingResponse to JSON.\n             * @function toJSON\n             * @memberof proto.PingResponse\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            PingResponse.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return PingResponse;\n        })();\n    \n        proto.PingResult = (function() {\n    \n            /**\n             * Properties of a PingResult.\n             * @memberof proto\n             * @interface IPingResult\n             * @property {string|null} [data] PingResult data\n             */\n    \n            /**\n             * Constructs a new PingResult.\n             * @memberof proto\n             * @classdesc Represents a PingResult.\n             * @implements IPingResult\n             * @constructor\n             * @param {proto.IPingResult=} [properties] Properties to set\n             */\n            function PingResult(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * PingResult data.\n             * @member {string} data\n             * @memberof proto.PingResult\n             * @instance\n             */\n            PingResult.prototype.data = "";\n    \n            /**\n             * Creates a new PingResult instance using the specified properties.\n             * @function create\n             * @memberof proto.PingResult\n             * @static\n             * @param {proto.IPingResult=} [properties] Properties to set\n             * @returns {proto.PingResult} PingResult instance\n             */\n            PingResult.create = function create(properties) {\n                return new PingResult(properties);\n            };\n    \n            /**\n             * Encodes the specified PingResult message. Does not implicitly {@link proto.PingResult.verify|verify} messages.\n             * @function encode\n             * @memberof proto.PingResult\n             * @static\n             * @param {proto.IPingResult} message PingResult message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PingResult.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.data != null && message.hasOwnProperty("data"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.data);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified PingResult message, length delimited. Does not implicitly {@link proto.PingResult.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.PingResult\n             * @static\n             * @param {proto.IPingResult} message PingResult message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PingResult.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a PingResult message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.PingResult\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.PingResult} PingResult\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PingResult.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PingResult();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.data = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a PingResult message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.PingResult\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.PingResult} PingResult\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PingResult.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a PingResult message.\n             * @function verify\n             * @memberof proto.PingResult\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            PingResult.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.data != null && message.hasOwnProperty("data"))\n                    if (!$util.isString(message.data))\n                        return "data: string expected";\n                return null;\n            };\n    \n            /**\n             * Creates a PingResult message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.PingResult\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.PingResult} PingResult\n             */\n            PingResult.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.PingResult)\n                    return object;\n                var message = new $root.proto.PingResult();\n                if (object.data != null)\n                    message.data = String(object.data);\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a PingResult message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.PingResult\n             * @static\n             * @param {proto.PingResult} message PingResult\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            PingResult.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.data = "";\n                if (message.data != null && message.hasOwnProperty("data"))\n                    object.data = message.data;\n                return object;\n            };\n    \n            /**\n             * Converts this PingResult to JSON.\n             * @function toJSON\n             * @memberof proto.PingResult\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            PingResult.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return PingResult;\n        })();\n    \n        proto.RPCRequest = (function() {\n    \n            /**\n             * Properties of a RPCRequest.\n             * @memberof proto\n             * @interface IRPCRequest\n             * @property {Uint8Array|null} [data] RPCRequest data\n             */\n    \n            /**\n             * Constructs a new RPCRequest.\n             * @memberof proto\n             * @classdesc Represents a RPCRequest.\n             * @implements IRPCRequest\n             * @constructor\n             * @param {proto.IRPCRequest=} [properties] Properties to set\n             */\n            function RPCRequest(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * RPCRequest data.\n             * @member {Uint8Array} data\n             * @memberof proto.RPCRequest\n             * @instance\n             */\n            RPCRequest.prototype.data = $util.newBuffer([]);\n    \n            /**\n             * Creates a new RPCRequest instance using the specified properties.\n             * @function create\n             * @memberof proto.RPCRequest\n             * @static\n             * @param {proto.IRPCRequest=} [properties] Properties to set\n             * @returns {proto.RPCRequest} RPCRequest instance\n             */\n            RPCRequest.create = function create(properties) {\n                return new RPCRequest(properties);\n            };\n    \n            /**\n             * Encodes the specified RPCRequest message. Does not implicitly {@link proto.RPCRequest.verify|verify} messages.\n             * @function encode\n             * @memberof proto.RPCRequest\n             * @static\n             * @param {proto.IRPCRequest} message RPCRequest message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            RPCRequest.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.data != null && message.hasOwnProperty("data"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified RPCRequest message, length delimited. Does not implicitly {@link proto.RPCRequest.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.RPCRequest\n             * @static\n             * @param {proto.IRPCRequest} message RPCRequest message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            RPCRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a RPCRequest message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.RPCRequest\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.RPCRequest} RPCRequest\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            RPCRequest.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RPCRequest();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.data = reader.bytes();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a RPCRequest message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.RPCRequest\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.RPCRequest} RPCRequest\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            RPCRequest.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a RPCRequest message.\n             * @function verify\n             * @memberof proto.RPCRequest\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            RPCRequest.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.data != null && message.hasOwnProperty("data"))\n                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))\n                        return "data: buffer expected";\n                return null;\n            };\n    \n            /**\n             * Creates a RPCRequest message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.RPCRequest\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.RPCRequest} RPCRequest\n             */\n            RPCRequest.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.RPCRequest)\n                    return object;\n                var message = new $root.proto.RPCRequest();\n                if (object.data != null)\n                    if (typeof object.data === "string")\n                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);\n                    else if (object.data.length)\n                        message.data = object.data;\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a RPCRequest message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.RPCRequest\n             * @static\n             * @param {proto.RPCRequest} message RPCRequest\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            RPCRequest.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.data = options.bytes === String ? "" : [];\n                if (message.data != null && message.hasOwnProperty("data"))\n                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;\n                return object;\n            };\n    \n            /**\n             * Converts this RPCRequest to JSON.\n             * @function toJSON\n             * @memberof proto.RPCRequest\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            RPCRequest.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return RPCRequest;\n        })();\n    \n        proto.RPCResponse = (function() {\n    \n            /**\n             * Properties of a RPCResponse.\n             * @memberof proto\n             * @interface IRPCResponse\n             * @property {proto.IError|null} [error] RPCResponse error\n             * @property {Uint8Array|null} [result] RPCResponse result\n             */\n    \n            /**\n             * Constructs a new RPCResponse.\n             * @memberof proto\n             * @classdesc Represents a RPCResponse.\n             * @implements IRPCResponse\n             * @constructor\n             * @param {proto.IRPCResponse=} [properties] Properties to set\n             */\n            function RPCResponse(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * RPCResponse error.\n             * @member {proto.IError|null|undefined} error\n             * @memberof proto.RPCResponse\n             * @instance\n             */\n            RPCResponse.prototype.error = null;\n    \n            /**\n             * RPCResponse result.\n             * @member {Uint8Array} result\n             * @memberof proto.RPCResponse\n             * @instance\n             */\n            RPCResponse.prototype.result = $util.newBuffer([]);\n    \n            /**\n             * Creates a new RPCResponse instance using the specified properties.\n             * @function create\n             * @memberof proto.RPCResponse\n             * @static\n             * @param {proto.IRPCResponse=} [properties] Properties to set\n             * @returns {proto.RPCResponse} RPCResponse instance\n             */\n            RPCResponse.create = function create(properties) {\n                return new RPCResponse(properties);\n            };\n    \n            /**\n             * Encodes the specified RPCResponse message. Does not implicitly {@link proto.RPCResponse.verify|verify} messages.\n             * @function encode\n             * @memberof proto.RPCResponse\n             * @static\n             * @param {proto.IRPCResponse} message RPCResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            RPCResponse.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.error != null && message.hasOwnProperty("error"))\n                    $root.proto.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                if (message.result != null && message.hasOwnProperty("result"))\n                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.result);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified RPCResponse message, length delimited. Does not implicitly {@link proto.RPCResponse.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof proto.RPCResponse\n             * @static\n             * @param {proto.IRPCResponse} message RPCResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            RPCResponse.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a RPCResponse message from the specified reader or buffer.\n             * @function decode\n             * @memberof proto.RPCResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {proto.RPCResponse} RPCResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            RPCResponse.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RPCResponse();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.error = $root.proto.Error.decode(reader, reader.uint32());\n                        break;\n                    case 2:\n                        message.result = reader.bytes();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a RPCResponse message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof proto.RPCResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {proto.RPCResponse} RPCResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            RPCResponse.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a RPCResponse message.\n             * @function verify\n             * @memberof proto.RPCResponse\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            RPCResponse.verify = function verify(message) {\n                if (typeof message !== "object" || message === null)\n                    return "object expected";\n                if (message.error != null && message.hasOwnProperty("error")) {\n                    var error = $root.proto.Error.verify(message.error);\n                    if (error)\n                        return "error." + error;\n                }\n                if (message.result != null && message.hasOwnProperty("result"))\n                    if (!(message.result && typeof message.result.length === "number" || $util.isString(message.result)))\n                        return "result: buffer expected";\n                return null;\n            };\n    \n            /**\n             * Creates a RPCResponse message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof proto.RPCResponse\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {proto.RPCResponse} RPCResponse\n             */\n            RPCResponse.fromObject = function fromObject(object) {\n                if (object instanceof $root.proto.RPCResponse)\n                    return object;\n                var message = new $root.proto.RPCResponse();\n                if (object.error != null) {\n                    if (typeof object.error !== "object")\n                        throw TypeError(".proto.RPCResponse.error: object expected");\n                    message.error = $root.proto.Error.fromObject(object.error);\n                }\n                if (object.result != null)\n                    if (typeof object.result === "string")\n                        $util.base64.decode(object.result, message.result = $util.newBuffer($util.base64.length(object.result)), 0);\n                    else if (object.result.length)\n                        message.result = object.result;\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a RPCResponse message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof proto.RPCResponse\n             * @static\n             * @param {proto.RPCResponse} message RPCResponse\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            RPCResponse.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.error = null;\n                    object.result = options.bytes === String ? "" : [];\n                }\n                if (message.error != null && message.hasOwnProperty("error"))\n                    object.error = $root.proto.Error.toObject(message.error, options);\n                if (message.result != null && message.hasOwnProperty("result"))\n                    object.result = options.bytes === String ? $util.base64.encode(message.result, 0, message.result.length) : options.bytes === Array ? Array.prototype.slice.call(message.result) : message.result;\n                return object;\n            };\n    \n            /**\n             * Converts this RPCResponse to JSON.\n             * @function toJSON\n             * @memberof proto.RPCResponse\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            RPCResponse.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return RPCResponse;\n        })();\n    \n        proto.Centrifuge = (function() {\n    \n            /**\n             * Constructs a new Centrifuge service.\n             * @memberof proto\n             * @classdesc Represents a Centrifuge\n             * @extends $protobuf.rpc.Service\n             * @constructor\n             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation\n             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n             */\n            function Centrifuge(rpcImpl, requestDelimited, responseDelimited) {\n                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);\n            }\n    \n            (Centrifuge.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Centrifuge;\n    \n            /**\n             * Creates new Centrifuge service using the specified rpc implementation.\n             * @function create\n             * @memberof proto.Centrifuge\n             * @static\n             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation\n             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n             * @returns {Centrifuge} RPC service. Useful where requests and/or responses are streamed.\n             */\n            Centrifuge.create = function create(rpcImpl, requestDelimited, responseDelimited) {\n                return new this(rpcImpl, requestDelimited, responseDelimited);\n            };\n    \n            /**\n             * Callback as used by {@link proto.Centrifuge#communicate}.\n             * @memberof proto.Centrifuge\n             * @typedef CommunicateCallback\n             * @type {function}\n             * @param {Error|null} error Error, if any\n             * @param {proto.Reply} [response] Reply\n             */\n    \n            /**\n             * Calls Communicate.\n             * @function communicate\n             * @memberof proto.Centrifuge\n             * @instance\n             * @param {proto.ICommand} request Command message or plain object\n             * @param {proto.Centrifuge.CommunicateCallback} callback Node-style callback called with the error, if any, and Reply\n             * @returns {undefined}\n             * @variation 1\n             */\n            Centrifuge.prototype.communicate = function communicate(request, callback) {\n                return this.rpcCall(communicate, $root.proto.Command, $root.proto.Reply, request, callback);\n            };\n    \n            /**\n             * Calls Communicate.\n             * @function communicate\n             * @memberof proto.Centrifuge\n             * @instance\n             * @param {proto.ICommand} request Command message or plain object\n             * @returns {Promise<proto.Reply>} Promise\n             * @variation 2\n             */\n    \n            return Centrifuge;\n        })();\n    \n        return proto;\n    })();\n\n    return $root;\n});\n\n\n//# sourceURL=webpack:///./src/Proto.js?')},"./src/Subscription.ts":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Subscription\", function() { return Subscription; });\n/* harmony import */ var _Functions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Functions */ \"./src/Functions.ts\");\n/* harmony import */ var js_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-observable */ \"./node_modules/js-observable/dist/observable.js\");\n/* harmony import */ var js_observable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(js_observable__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Proto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Proto */ \"./src/Proto.js\");\n/* harmony import */ var _Proto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Proto__WEBPACK_IMPORTED_MODULE_2__);\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\n\r\n\r\nvar Subscription = (function (_super) {\r\n    __extends(Subscription, _super);\r\n    function Subscription(centrifuge, channel, events) {\r\n        var _this = _super.call(this) || this;\r\n        _this.channel = null;\r\n        _this._status = 'new';\r\n        _this._error = null;\r\n        _this._centrifuge = null;\r\n        _this._isResubscribe = false;\r\n        _this._recovered = false;\r\n        _this._ready = false;\r\n        _this._noResubscribe = false;\r\n        _this._promise = null;\r\n        _this._centrifuge = centrifuge;\r\n        _this.channel = channel;\r\n        _this.setEvents(events);\r\n        _this._initializePromise();\r\n        return _this;\r\n    }\r\n    Object.defineProperty(Subscription.prototype, \"isUnsubscribed\", {\r\n        get: function () {\r\n            return this._status === 'unsubscribed';\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Subscription.prototype, \"isSuccess\", {\r\n        get: function () {\r\n            return this._status === 'success';\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Subscription.prototype, \"isSubscribing\", {\r\n        get: function () {\r\n            return this._status === 'subscribing';\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Subscription.prototype.setEvents = function (events) {\r\n        if (!events) {\r\n            return;\r\n        }\r\n        if (Object(_Functions__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(events)) {\r\n            this.on('message', events);\r\n        }\r\n        else if (Object.prototype.toString.call(events) === Object.prototype.toString.call({})) {\r\n            var knownEvents = ['message', 'join', 'leave', 'unsubscribe', 'subscribe', 'error'];\r\n            for (var i = 0, l = knownEvents.length; i < l; i++) {\r\n                var ev = knownEvents[i];\r\n                if (ev in events) {\r\n                    this.on(ev, events[ev]);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Subscription.prototype.setNew = function () {\r\n        this._status = 'new';\r\n    };\r\n    Subscription.prototype.setSubscribing = function () {\r\n        if (this._ready === true) {\r\n            this._initializePromise();\r\n            this._isResubscribe = true;\r\n        }\r\n        this._status = 'subscribing';\r\n    };\r\n    Subscription.prototype.setUnsubscribed = function (noResubscribe) {\r\n        if (this._status === 'unsubscribed') {\r\n            return;\r\n        }\r\n        this._status = 'unsubscribed';\r\n        if (noResubscribe === true) {\r\n            this._noResubscribe = true;\r\n        }\r\n        this.triggerUnsubscribe();\r\n    };\r\n    Subscription.prototype.setSubscribeSuccess = function (recovered) {\r\n        if (this.isSuccess) {\r\n            return;\r\n        }\r\n        this._recovered = recovered;\r\n        this._status = 'success';\r\n        var successContext = this._getSubscribeSuccess();\r\n        this.trigger('subscribe', [successContext]);\r\n        this._resolve(successContext);\r\n    };\r\n    Subscription.prototype.setSubscribeError = function (error) {\r\n        if (this._status === 'error') {\r\n            return;\r\n        }\r\n        this._status = 'error';\r\n        this._error = error;\r\n        this.trigger('error', [error]);\r\n        this._reject(error);\r\n    };\r\n    Subscription.prototype.triggerUnsubscribe = function () {\r\n        this.trigger('unsubscribe', [{\r\n                channel: this.channel\r\n            }]);\r\n    };\r\n    Subscription.prototype.shouldResubscribe = function () {\r\n        return !this._noResubscribe;\r\n    };\r\n    Subscription.prototype.ready = function (callback, errback) {\r\n        if (this._ready) {\r\n            if (this.isSuccess) {\r\n                callback(this._getSubscribeSuccess());\r\n            }\r\n            else {\r\n                errback(this._error);\r\n            }\r\n        }\r\n    };\r\n    Subscription.prototype.subscribe = function () {\r\n        if (this.isSuccess) {\r\n            return;\r\n        }\r\n        this._centrifuge.subscribeSub(this);\r\n        return this;\r\n    };\r\n    Subscription.prototype.unsubscribe = function () {\r\n        this.setUnsubscribed(true);\r\n        this._centrifuge.unsubscribeSub(this);\r\n    };\r\n    Subscription.prototype.publish = function (data) {\r\n        return this._request(_Proto__WEBPACK_IMPORTED_MODULE_2__[\"proto\"].MethodType.PUBLISH, data);\r\n    };\r\n    Subscription.prototype.presence = function () {\r\n        return this._request(_Proto__WEBPACK_IMPORTED_MODULE_2__[\"proto\"].MethodType.PRESENCE);\r\n    };\r\n    Subscription.prototype.history = function () {\r\n        return this._request(_Proto__WEBPACK_IMPORTED_MODULE_2__[\"proto\"].MethodType.HISTORY);\r\n    };\r\n    Subscription.prototype._initializePromise = function () {\r\n        var _this = this;\r\n        this._ready = false;\r\n        this._promise = new Promise(function (resolve, reject) {\r\n            _this._resolve = function (value) {\r\n                _this._ready = true;\r\n                resolve(value);\r\n            };\r\n            _this._reject = function (err) {\r\n                _this._ready = true;\r\n                reject(err);\r\n            };\r\n        });\r\n    };\r\n    Subscription.prototype._getSubscribeSuccess = function () {\r\n        return {\r\n            channel: this.channel,\r\n            isResubscribe: this._isResubscribe,\r\n            recovered: this._recovered\r\n        };\r\n    };\r\n    Subscription.prototype._request = function (method, data) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            if (_this.isUnsubscribed) {\r\n                reject({\r\n                    message: 'Subscription unsubscribed',\r\n                });\r\n                return;\r\n            }\r\n            _this._promise.then(function () {\r\n                if (!_this._centrifuge.isConnected) {\r\n                    reject({\r\n                        message: 'Disconnected',\r\n                    });\r\n                    return;\r\n                }\r\n                var params = {\r\n                    channel: _this.channel,\r\n                };\r\n                if (data) {\r\n                    params['data'] = data;\r\n                }\r\n                _this._centrifuge.addCommand({\r\n                    method: method,\r\n                    params: params,\r\n                }).then(function (response) {\r\n                    resolve(response);\r\n                }, function (error) {\r\n                    reject(error);\r\n                });\r\n            }, function (err) {\r\n                reject(err);\r\n            });\r\n        });\r\n    };\r\n    return Subscription;\r\n}(js_observable__WEBPACK_IMPORTED_MODULE_1__[\"Observable\"]));\r\n\r\n\n\n//# sourceURL=webpack:///./src/Subscription.ts?")}})});